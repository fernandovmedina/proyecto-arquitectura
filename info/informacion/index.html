<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content="Astro description" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="../../logo.png" />
    <meta name="generator" content="Astro v3.6.0" />
    <title>Informacion unidades</title>
    <link rel="stylesheet" href="../../_astro/index.35c52348.css" />
  </head>
  <body>
    <section class="bg-black text-white">
      <nav
        class="flex flex-row w-full items-center px-10 py-5 bg-black text-white border-b border-indigo-800"
      >
        <div class="md:w-1/2 w-1/3">
          <a href="/"
            ><img
              src="../../_astro/logo.2e0258cc_Z60Gle.webp"
              class="w-16"
              alt="Logo de Arquitectura de Computadoras"
              width="96"
              height="96"
              loading="lazy"
              decoding="async"
          /></a>
        </div>
        <div
          class="md:w-1/2 w-2/3 flex flex-col text-right md:justify-evenly md:flex-row text-sm md:text-lg"
        >
          <a href="../../index.html" class="hover:underline hover:text-purple-800">Inicio</a>
          <a href="../../practicas/index.html" class="hover:underline hover:text-purple-800"
            >Practicas</a
          >
          <a href="../../temario/index.html" class="hover:underline hover:text-purple-800"
            >Temario</a
          >
          <a
            href="../../info/informacion/index.html"
            class="hover:underline hover:text-purple-800"
            >Informacion Unidades</a
          >
        </div>
      </nav>
      <div class="py-20 px-10">
        <h1 class="text-5xl pb-10">Unidades</h1>
        <div class="px-10">
          <h3>UNIDAD 1</h3>
          <h2>1.1 Modelos de Arquitectura de Cómputo</h2>
          <hr />
          <p>
            La arquitectura de computadoras es el diseño y la organización de un
            sistema para un equipo de cómputo. Es un modelo y descripción de
            cada función, así como los requerimientos y las implementaciones de
            diseño para varias partes del equipo de cómputo.
          </p>
          <p><br /></p>
          <h1>1.1.1 Clásicas</h1>
          <p>
            Estas arquitecturas se desarrollaron en las primeras computadoras
            electromecánicas y de tubos de vacío.
          </p>
          <p>
            Hay dos arquitecturas distintas relacionadas con el uso y
            distribución de la memoria: Arquitectura de Jonh Von Neumman y
            Arquitectura Harvard.
          </p>
          <p><br /></p>
          <h4><i> Arquitectura Von Neumann</i></h4>
          <p>
            Tradicionalmente los sistemas de microprocesadores se basan en esta
            arquitectura, en la cual la unidad central de proceso (CPU), está
            conectada a una memoria principal única donde se guardan las
            instrucciones del programa y los datos. A dicha memoria se accede a
            través de un sistema interconexión de buses único (control,
            direcciones y datos)..
          </p>
          <p><br /></p>
          <p>
            En un sistema con arquitectura Von Neumann el tamaño de la unidad de
            datos o instrucciones está fijado por el ancho del bus que comunica
            la memoria con la CPU. Así un microprocesador de 8 bits con un bus
            de 8 bits, tendrá que manejar datos e instrucciones de una o más
            unidades de 8 bits (bytes) de longitud.
          </p>
          <p><br /></p>
          <p>
            Si tiene que ceder a una instrucción o datos de más de un byte de
            longitud, tendrá que realizar más de un acceso a la memoria. El
            tener un único bus hace que el microprocesador sea más lento en su
            respuesta, ya que no puede buscar en memoria una nueva instrucción
            mientras no finalicen las transferencias de datos de la instrucción
            anterior.
          </p>
          <p>
            Las computadoras digitales convencionales presentan un aspecto Von
            Neumann.
          </p>
          <p>Este modelo consta de cinco componentes principales:</p>
          <p>-Unidad de memoria</p>
          <p>-Unidad de entrada/salida</p>
          <p>-Unidad de control.</p>
          <p>-Unidad aritmética lógica.</p>
          <p>-Registro de Programas.</p>
          <h4><i> Modelo Harvard</i></h4>
          <p>
            Esta arquitectura utiliza los Micro controladores, tiene la unidad
            central de proceso (CPU) conectada a dos memorias (una con las
            instrucciones y otra con los datos) por medio de dos buses
            diferentes.
          </p>
          <p><br /></p>
          <p>
            Una de las memorias contiene solamente las instrucciones del
            programa (Memoria de Programa), y la otra sólo almacena datos
            (Memoria de Datos). Ambos buses son totalmente independientes lo que
            permite que la CPU pueda acceder de forma independiente y simultánea
            a la memoria de datos y a la de instrucciones. El tamaño de las
            instrucciones no está relacionado con el de los datos, y por lo
            tanto puede ser optimizado para que cualquier instrucción ocupe una
            sola posición de memoria de programa, logrando así mayor velocidad y
            menor longitud de programa.
          </p>
          <p><br /></p>
          <p>
            La principal desventaja de esta arquitectura; el bus de datos y
            direcciones único se convierte en un cuello de botella por el cual
            debe pasar toda la información que se lee de o se escribe a la
            memoria, obligando a que todos los accesos a esta sean secuenciales.
            Limita el grado de paralelismo (acciones que se pueden realizar al
            mismo tiempo) y por lo tanto, el desempeño de la computadora.
          </p>
          <p><br /></p>
          <h1>1.1.2 Segmentadas</h1>
          <p>
            Es una de las tecnologías utilizadas para realizar la segmentación o
            paralelismo. Divide el procesador, en etapas, procesa una
            instrucción diferente en cada una y trabaja con varias a la vez.
          </p>
          <p><br /></p>
          <p>
            Pueden trabajar de forma paralela, en diferentes instrucciones,
            utilizando una cola de instrucciones para su comunicación,
            denominado entubamiento. La técnica de implementación clave
            utilizada para hacer CPU.
          </p>
          <p><br /></p>
          <p>
            La dependencia de datos y de control, que tiene como efecto la
            disminución del rendimiento del <b> pipelining</b>.
          </p>
          <p>
            La segmentación de cauce (pipelining) es una forma efectiva de
            organizar el hardware del CPU para realizar más de una operación al
            mismo tiempo. Consiste en descomponer el proceso de ejecución de las
            instrucciones en fases o etapas que permitan una ejecución
            simultánea.
          </p>
          <p><br /></p>
          <p>
            Las etapas están conectadas, cada una a la siguiente, para formar
            una especie de cauce las instrucciones se entran por un extremo, son
            procesadas a través de las etapas y salen por el otro. La
            productividad de la segmentación está determinada por la frecuencia
            con que una instrucción salga del cauce.
          </p>
          <p><br /></p>
          <h1>1.1.3 Multiprocesamiento</h1>
          <p>
            Se denomina multiprocesador a un computador que cuenta con dos o más
            microprocesadores (CPUs). La arquitectura NUMA, donde cada
            procesador tiene acceso y control exclusivo a una parte de la
            memoria. La arquitectura SMP, donde todos los procesadores comparten
            toda la memoria.
          </p>
        </div>
        <p><br /></p>
        <p>
          Para que un multiprocesador opere correctamente necesita un sistema
          operativo especialmente diseñado para ello.
        </p>
        <p>
          <i>
            <u>
              La arquitectura NUMA, donde cada procesador tiene acceso y control
              exclusivo a una parte de la memoria. La arquitectura SMP, donde
              todos los procesadores comparten toda la memoria.</u
            ></i
          >
        </p>
        <p><br /></p>
        <p>
          Los CPU de multiprocesamiento según Flynn se clasifican de la
          siguiente manera:
        </p>
        <p></p>
        <ul>
          <li>
            SISO : (Single Instruction, Single Operand) computadoras.
            Monoprocesador
          </li>
          <li>
            SIMO : (Single Instruction, Multiple Operand) procesadores
            vectoriales, Exenciones MMX
          </li>
          <li>MISO : (Multiple Instruction, Single Operand) No implementado</li>
          <li>
            MIMO : (Multiple Instruction, Multiple Operand) sistemas SMP,
            Clusters, GPUs
          </li>
        </ul>
        <p><br /></p>
        <p>
          Los procesadores vectoriales, son computadoras pensadas para aplicar
          un mismo algoritmo numérico a una serie de datos matriciales, en
          especial en la simulación de sistemas físicos complejos, tales como
          simuladores de clima, explosiones atómicas, reacciones químicas, etc.
          Donde los datos son representados como grandes números de datos en
          forma matricial sobre los que se deben se aplicar el mismo algoritmo
          numérico.
        </p>
        <p>
          Los Procesadores Digitales de Señales (DSP), son procesadores
          especializados en el procesamiento de señales tales como audio, vídeo,
          radar, sonar, radio, etc. Cuentan con instrucciones tipo vectorial que
          los hace muy aptos para dicha aplicación.
        </p>
        <p><br /></p>
        <h4><i> SMP</i></h4>
        <p>
          En los sistemas SMP (Simetric Multiprocessing), varios procesadores
          comparten la misma memoria principal y periféricos de Entrada /Salida,
          normalmente conectados por un bus común.
        </p>
        <p><br /></p>
        <p>
          Se conocen como simétricos, ya que ningún procesador toma el papel de
          maestro y los demás de esclavos, sino que todos tienen derechos
          similares en cuanto al acceso a la memoria y periféricos y ambos son
          administrados por el sistema operativo. Pueden formarse con varios
          núcleos en un solo circuito integrado o con varios circuitos
          integrados en una misma tarjeta madre. La primera opción ha sido
          popularizada al hacerse más económicos los procesadores multinúcleo de
          los principales fabricantes y con su uso en sistemas de gama media y
          baja, e inclusive en teléfonos celulares y tabletas.
        </p>
        <p><br /></p>
        <p>
          La segunda opción fue la que se uso en un principio y sigue siendo
          usada en en estaciones de trabajo y en servidores de alto rendimiento
          debido a que incrementa el poder computacional del sistema, pero
          también incrementa considerablemente el costo del sistema.
        </p>
        <p><br /></p>
        <h4><i> Clusters</i></h4>
        <p>
          Conjuntos de computadoras independientes conectadas en una red de área
          local o por un bus de interconexión y que trabajan cooperativamente.
          Con un sistema de procesamiento paralelo o distribuido.
        </p>
        <p><br /></p>
        <p>
          Es clave en su funcionamiento contar con un sistema operativo y
          programas de aplicación capaces de distribuir el trabajo entre las
          computadoras de la red.
        </p>
        <p><br /></p>
        <p>
          Se debe tener cuidado al implementar la aplicación, ya que si los
          datos que hay que pasar de un procesador a otro son demasiados, el
          tiempo empleado en pasar información de un nodo a otro puede
          sobrepasar a la ganancia que se tiene al dividir el trabajo entre
          varios procesadores.
        </p>
        <p><br /></p>
        <p><br /></p>
        <h2>1.2 Análisis de Componentes</h2>
        <hr />
        <p>
          Los programas cada vez más grandes y complejos demandan mayor
          velocidad en el procesamiento de información, lo que implica la
          elección de microprocesadores más rápidos y eficientes.
        </p>
        <p><br /></p>
        <h1>1.2.1 Arquitecturas</h1>
        <p><br /></p>
        <h4><i> Arquitecturas Cisc</i></h4>
        <p>
          En la arquitectura computacional, CISC es un modelo de arquitectura,
          en donde los microprocesadores tienen un conjunto instrucciones que
          caracterizan por ser muy amplio y permitir operaciones complejas entre
          operandos, situados en la memoria o en los registros internos.
        </p>
        <p><br /></p>
        <p>
          Este tipo de arquitectura dificulta el paralelismo entre
          instrucciones, por lo que, en la actualidad, la mayoría de los
          sistemas CISC de alto rendimiento implementan un sistema que convierte
          dichas instrucciones complejas en varias instrucciones simples del
          tipo RISC, llamadas generalmente microinstrucciones.
        </p>
        <p><br /></p>
        <p>
          <b> Dato importante:</b> Los CISC pertenecen a la primera corriente de
          construcción de procesadores, antes del desarrollo de los RISC. Ademas
          Para realizar una sola instrucción un chip CISC requiere de cuatro a
          diez ciclos de reloj.
        </p>
        <p><br /></p>
        <p>Entre las ventajas de CISC destacan las siguientes:</p>
        <ul>
          <li>Reduce la dificultad de crear compiladores.</li>
          <li>Permite reducir el costo total del sistema.</li>
          <li>Reduce los costos de creación de software.</li>
          <li>Mejora la compactación de código.</li>
          <li>Facilita la depuración de errores.</li>
        </ul>
        <p><br /></p>
        <h4><i> Arquitecturas Cisc</i></h4>
        <p>
          Arquitectura computacional, RISC (Reduced Instruction Set Computer) es
          un tipo de microprocesador con las siguientes características
          fundamentales:
        </p>
        <p></p>
        <ul>
          <li>
            Instrucciones de tamaño fijo y presentado en un reducido número de
            formatos.
          </li>
          <li>
            Sólo las instrucciones de carga y almacenamiento acceden a la
            memoria de datos.
          </li>
          <li>
            El objetivo de diseñar máquinas con esta arquitectura es posibilitar
            la segmentación y el paralelismo en la ejecución
          </li>
          <li>de instrucciones y reducir los accesos a memoria.</li>
          <li>
            Las máquinas RISC protagonizan la tendencia actual de construcción
            de microprocesadores.
          </li>
        </ul>
        <p><br /></p>
        <p><br /></p>
        <h1>1.2.1.1 CPU</h1>
        <p>
          Se la suele llamar coloquialmente como microprocesador o simplemente
          procesador, y puedes considerarla como el cerebro de cualquier
          dispositivo. Se encarga de procesar todas las instrucciones del
          dispositivo, leyendo las órdenes y requisitos del sistema operativo,
          así como las instrucciones de cada uno de los componentes y las
          aplicaciones.
        </p>
        <p><br /></p>
      </div>
      <p><br /></p>
      <p>
        CPU es la que se encarga de que todo funcione correctamente, y de
        interpretar todo lo que quiere hacer el sistema operativo o los
        componentes, estableciendo las conexiones y realizando todos los
        cálculos precisos para que funcione. Cuanto más potente sea el
        procesador, más rápido podrá hacer las operaciones y más rápido
        funcionará tu dispositivo en general.
      </p>
      <p>
        Los CPUs modernos se pueden clasificar por sus características como:
      </p>
      <p></p>
      <ul>
        <li>Tamaño de la Unidad Aritmética Lógica (ALU).</li>
        <li>Bus de conexión al exterior (8, 16, 32, 64 bits).</li>
        <li>Si su arquitectura tiene cauce (pipeline).</li>
        <li>Si son de arquitectura CISC o RISC.</li>
        <li>Si son Von Newmann o Harvard.</li>
        <li>
          Si manejan instrucciones enteras o implementan también instrucciones
          de punto flotante.
        </li>
      </ul>
      <p><br /></p>
      <p>
        No hace mucho tiempo, el procesador era algo totalmente desconocido por
        los usuarios de PCs. Esto fue cambiando con el tiempo y en la actualidad
        cualquier persona al comprar un equipo se pregunta acerca de los
        atributos elementales de este dispositivo. Es que el procesador es una
        parte esencial de la computadora, por eso generalmente se la conoce como
        su “cerebro”.
      </p>
      <p><br /></p>
      <h1 id="1.2.1.2">1.2.1.2 ALU</h1>
      <p class="text">
        Es un circuito logico digital que realiza operaciones aritmeticas y
        logicas entres los datos de un circuito: suma resta, division y
        multiplicacion, asi como establece comparaciones logicas a traves de los
        condicionales logicos "si", "no", y "o".
      </p>
      <p><br /></p>
      <p class="text">
        Todos los microprocesadores incluyen al menos una ALU, que varia su
        poder y complejidadsegún su finalidad Además, la ALU cuenta con una
        serie de registros para almacenar los datos y bits de informacion sobre
        los resultados.
      </p>
      <p><br /></p>
      <p class="text">Operaciones a realizar por la ALU:</p>
      <ul class="indt">
        <li>Suma aritmetica</li>
        <li>Resta aritmetica</li>
        <li>peraciones lógicas</li>
        <li>Desplazamiento o rotación</li>
        <li>Transferencia</li>
      </ul>
      <p><br /></p>
      <p class="text">
        El circuito ALU es solo un operador, no puede tomar decisiones. Las
        entradas deben contener tanto la magnitud como el signo que corresponda
        a la operacion.
      </p>
      <p><br /></p>
      <p class="text">
        La ALU deberá contar con un circuito de control que le permita:
      </p>
      <ul class="indt">
        <li>Identificar la operación a realizar</li>
        <li>Administrar los recursos internos.</li>
        <li>Generar las banderas</li>
      </ul>
      <p><br /></p>
      <h1 id="1.2.1.3">1.2.1.3 Registros</h1>
      <p class="text">
        Los registros que encuentran dentro de cada procesador su función
        principales almacenar los valores de cada uno de los
        datos,comandos,instrucciones o estados binarios que son los que ordenan
        qué dato debe procesarse, así como la forma en la que se debe realizar.
      </p>
      <p><br /></p>
      <p class="text">
        Un registro no deja de ser una memoria de velocidad alta y con poca
        capacidad. Cada registro puede contener una instrucción, una dirección
        de almacenamiento o cualquier tipo de dato.
      </p>
      <p><br /></p>
      <p class="text">
        Cada procesador tiene varias asignaciones o tareas que debe de realizar
        para el manejo de la información. La información es recibida
        generalmente en código binario, procedente de las aplicaciones para,
        después, procesarlos de una forma determinada.
      </p>
      <p><br /></p>
      <p class="text">
        <b><i>Tipos de registros</i></b>
      </p>
      <p class="text">
        Los registros del procesador se dividen o clasifican atendiendo al
        propósito que sirven o a las instrucciones que les ordenan.
      </p>
      <p><br /></p>
      <p class="text">
        <b>Registros de datos:</b> Guardan valores de datos numéricos, como son
        los caracteres o pequeñas órdenes. Los procesadores antiguos tenían un
        registro especial de datos: el acumulador, el cual era usado para
        operaciones determinadas.
      </p>
      <p><br /></p>
      <p class="text">
        <b>Registros de datos de memoria (MDR):</b>Es un registro que se
        encuentra en el procesador y que está conectado al bus de datos. Tiene
        poca capacidad y una velocidad alta por la que escribe o lee los datos
        del bus que van dirigidos a la memoria o al puerto E/S, es decir, un
        periférico.
      </p>
      <p><br /></p>
      <p class="text">
        <b>Registros de direcciones:</b> Guardan direcciones que son usadas para
        acceder a la memoria principal o primaria, que solemos conocer como ROM
        o RAM. En este sentido, podemos ver procesadores con registros que se
        usan solo para guardar direcciones o valores numéricos.
      </p>
      <p><br /></p>
      <p class="text">
        <b>Registros de propósito general (GPRs):</b>Son registros que sirven
        para almacenar direcciones o datos generales. Se trata de una especie de
        registros mixtos que, como su propio indica, no tienen una función
        específica.
      </p>
      <p><br /></p>
      <p class="text">
        <b>Registros de propósito específico (SPRs):</b>En esta ocasión, estamos
        ante registros que guardan datos del estado del sistema, como puede ser
        el registro de estado o el instruction pointer.
      </p>
      <p><br /></p>
      <p class="text">
        <b>Registros de estado:</b>Sirven para guardar valores reales cuya
        función es determinar cuándo una instrucción debe ejecutarse o no.
      </p>
      <p><br /></p>
      <p class="text">
        <b>Registros constantes:</b>Su cometido es guardar valores de sólo
        lectura como son el 0, 1 ó π.
      </p>
      <p><br /></p>
      <h1 id="1.2.1.4">1.2.1.4 Buses</h1>
      <p class="text">
        Un bus se puede definir como una línea de interconexión portadora de
        información, constituida por varios hilos conductores (en sentido
        físico) o varios canales (en sentido de la lógica), por cada una de las
        cuales se transporta un bit de información.
      </p>
      <p><br /></p>
      <p class="text">
        Existen dos tipos primordiales de buses (conexiones) para el envío de la
        información: bus paralelo o serial:
      </p>
      <p><br /></p>
      <p class="text">
        <b>Bus paralelo:</b>Es un bus en el cual los datos son enviados por
        bytes al mismo tiempo, con la ayuda de varias líneas que tienen
        funciones fijas. La cantidad de datos enviada es bastante grande con una
        frecuencia moderada y es igual al ancho de los datos por la frecuencia
        de funcionamiento. En los computadores ha sido usado de manera
        intensiva, desde el bus del procesador, los buses de discos duros,
        tarjetas de expansión y de vídeo hasta las impresoras.
      </p>
      <p><br /></p>
      <p class="text">
        <b>Bus serie:</b>En este los datos son enviados, bit a bit y se
        reconstruyen por medio de registros o rutinas de software. Está formado
        por pocos conductores y su ancho de banda depende de la frecuencia. Es
        usado desde hace menos de 10 años en buses para discos duros, tarjetas
        de expansión y para el bus del procesador.
      </p>
      <p><br /></p>
      <p class="text"><b>Buses del procesador:</b></p>
      <p><br /></p>
      <p class="text">
        <b>Bus de direcciones:</b> Es unidireccional debido a que la información
        fluye es una solo sentido, del CPU a la memoria ó a los elementos de
        entrada y salida. El CPU puede colocar niveles lógicos en las n líneas
        de dirección, con la cual se genera 2n posibles direcciones diferentes.
        Cada una de estas direcciones corresponde a una localidad de la memoria
        ó dispositivo de E / S. El procesador envía un código de dirección a la
        memoria o a otro dispositivo externo. El tamaño o anchura del bus de
        direcciones está especificado por el número de hilos conductores o
        pines.
      </p>
      <p><br /></p>
      <p class="text">
        <b>Bus de datos:</b> Es bidireccional, pues los datos pueden fluir hacia
        ó desde el CPU.Las terminales pueden ser entradas ó salidas, según la
        operación que se este realizando ( lectura ó escritura ).En todos los
        casos, las palabras de datos transmitidas tiene m bits de longitud
        debido a que el CPU maneja palabras de datos de m bits; del número de
        bits del bus de datos, depende la clasificación del procesador.En
        algunos procesadores, el bus de datos se usa para transmitir otra
        información además de los datos.Es compartido en el tiempo ó
        multiplexado. Transfieren datos o códigos de instrucción hacia el
        procesador o se envían hacia el exterior los resultados de las
        operaciones o cálculos.
      </p>
      <p><br /></p>
      <p class="text">
        <b>Bus de control:</b>Este conjunto de señales se usa para sincronizar
        las actividades y transacciones con los periféricos del sistema. Algunas
        de estas señales, como Lectura o Escritura R / W , son señales que el
        CPU envía para indicar que tipo de operación se espera en ese momento.
      </p>
      <p><br /></p>
      <img
        src="https://conceptoabc.com/wp-content/uploads/2021/05/tecno-bus-SATA.jpg"
      />
      <h1 id="1.2.2">1.2.2 Memoria</h1>
      <p class="text">
        Es un dispositivo que puede mantenerse en por lo menos dos estados
        estables por un cierto periodo de tiempo. Cada uno de estos estados
        estables puede utilizarse para representar un bit. A un dispositivo con
        la capacidad de almacenar por lo menos un bit se le conoce como celda
        básica de memoria.
      </p>
      <p><br /></p>
      <p><br /></p>
      <p class="text">
        Un dispositivo de memoria completo se forma con varias celdas básicas y
        los circuitos asociados para poder leer y escribir dichas celdas
        básicas, agrupadas como localidades de memoria que permitan almacenar un
        grupo de N bits.
      </p>
      <p><br /></p>
      <h1 id="1.2.2.1">1.2.2.1 Manejo de memoria</h1>
      <p class="text">
        La gestión de memoria o administración de memoria es el acto de
        gestionar la memoria de un dispositivo informático. El proceso de
        asignación de memoria a los programas que la solicitan. La gestión de la
        memoria principal de una computadora es una tarea de suma importancia
        para el funcionamiento de la misma.
      </p>
      <p><br /></p>
      <p class="text">
        Los sistemas de memoria virtual separan las direcciones de memoria
        utilizadas por un proceso de las direcciones físicas reales, permitiendo
        la separación de procesos e incrementando la cantidad efectiva de
        memoria de acceso aleatorio utilizando la paginación. La calidad de la
        gestión de la memoria es crucial para las prestaciones del sistema.
      </p>
      <p><br /></p>
      <p class="text">
        La administración de memoria se refiere a los distintos métodos y
        operaciones que se encargan de obtener la máxima utilidad de la memoria,
        organizando los procesos y programas que se ejecutan de manera tal que
        se aproveche de la mejor manera posible el espacio disponible.
      </p>
      <p><br /></p>
      <p class="text">
        Las técnicas que existen para la carga de programas en la memoria son:
        partición fija, que es la división de la memoria libre en varias partes
        (de igual o distinto tamaño) y la partición dinámica, que son las
        particiones de la memoria en tamaños que pueden ser variables, según la
        cantidad de memoria que necesita cada proceso.
      </p>
      <p><br /></p>
      <h1 id="1.2.2.2">1.2.2.2 Memoria principal</h1>
      <p class="text">
        La memoria del semiconductor utiliza en su arquitectura circuitos
        integrados basados en semiconductores para almacenar información. Un
        chip de memoria de semiconductor puede contener millones de minúsculos
        transistores o condensadores. Existen memorias de semiconductor de ambos
        tipos: volátiles y no volátiles.
      </p>
      <p><br /></p>
      <p class="text">
        En las computadoras modernas, la memoria principal consiste casi
        exclusivamente en memoria de semiconductor volátil y dinámica, también
        conocida como memoria dinámica de acceso aleatorio o más comúnmente RAM
        (Random Access Memory).
      </p>
      <p><br /></p>
      <h1 id="1.2.2.3">1.2.2.3 Memoria caché</h1>
      <p class="text">
        Es la memoria de acceso rápido de una computadora, que guarda
        temporalmente las últimas informaciones procesadas. La memoria caché es
        un búfer especial de memoria que poseen las computadoras, que funciona
        de manera similar a la memoria principal, pero es de menor tamaño y de
        acceso más rápido. Es usada por el procesador para reducir el tiempo de
        acceso a datos ubicados en la memoria principal que se utilizan con más
        frecuencia.
      </p>
      <p><br /></p>
      <p class="text">
        La caché es una memoria que se sitúa entre la unidad central de
        procesamiento (CPU) y la memoria de acceso aleatorio (RAM) para acelerar
        el intercambio de datos. Cuando se accede por primera vez a un dato, se
        hace una copia en la caché; los accesos siguientes se realizan a dicha
        copia, haciendo que sea menor el tiempo de acceso medio al dato.
      </p>
      <p><br /></p>
      <p class="text">
        Cuando el procesador necesita leer o escribir en una ubicación en
        memoria principal, primero verifica si una copia de los datos está en la
        memoria caché; si es así, el procesador de inmediato lee o escribe en la
        memoria caché, que es mucho más rápido que de la lectura o la escritura
        a la memoria principal.
      </p>
      <p><br /></p>
      <p class="text">
        La memoria caché cuenta con 3 niveles, cada uno teniendo más caché pero
        siendo mas lenta, siendo la de nivel 3 la más lenta.
      </p>
      <p><br /></p>
      <h1 id="1.2.3">1.2.3 Manejo de Entrada/Salida</h1>
      <h1 id="1.2.3.1">1.2.3.1 Módulos E/S</h1>
      <p class="text">
        Para poder hacer una operación entre el procesador y un periférico, se
        necesita conectar estos dispositivos a la computadora y gestionar de
        manera correcta la transferencia de datos. Esto, se puede realizar
        mediante los sistemas de módulos de Entrada/Salida. Estos módulos están
        conectados con el procesador y la memoria principal, cada uno controla
        uno o más dispositivos externos.
      </p>
      <p><br /></p>
      <h1 id="1.2.3.2">1.2.3.2 E/S Programada</h1>
      <p class="text">
        La entrada-salida programada (también entrada / salida programada , E /
        S programada , PIO ) es un método de transmisión de datos , a través de
        entrada / salida (E / S), entre una unidad central de procesamiento
        (CPU) y un dispositivo periférico , como un adaptador de red o un
        dispositivo de almacenamiento Parallel ATA (PATA, anteriormente AT
        Attachment (ATA)). Cada transferencia de elementos de datos se inicia
        mediante una instrucción en el programa, que involucra a la CPU para
        cada transacción. Por el contrario, en las operaciones de acceso directo
        a memoria (DMA), la CPU no participa en la transferencia de datos.
      </p>
      <p><br /></p>
      <p class="text">
        El término puede referirse a E / S mapeadas en memoria (MMIO) o E / S
        mapeadas en puertos (PMIO). PMIO se refiere a transferencias que
        utilizan un espacio de direcciones especial fuera de la memoria normal,
        al que generalmente se accede con instrucciones dedicadas, comoEN y
        FUERAen arquitecturas x86 . MMIO [1] se refiere a transferencias a
        dispositivos de E / S que están mapeados en el espacio de direcciones
        normal disponible para el programa. PMIO fue muy útil para los primeros
        microprocesadores con espacios de direcciones pequeños, ya que los
        dispositivos de E / S no consumían el valioso recurso.
      </p>
      <p><br /></p>
      <h1 id="1.2.3.3">1.2.3.3 E/S Meduante Interrupciones</h1>
      <p class="text">
        Esta técnica pretende evitar que el procesador pare o haga trabajo
        improductivo, mientras que espera a que el periférico esté preparado
        para hacer una nueva operación. El hardware de la computadora, necesita
        tener un conjunto de líneas de control del bus del sistema y de petición
        de interrupción.
      </p>
      <p><br /></p>
      <p class="text"><b>Funcionamiento:</b></p>
      <p class="text">
        El procesador ejecuta instrucciones de un programa. Al finalizar cada
        instrucción comprueba si se ha producido una interrupción.
      </p>
      <p class="text">
        En caso afirmativo se salva el estado actual del programa (contador del
        programa y registros) y se salta a ejecutar la rutina de servicio
        correspondiente.
      </p>
      <p class="text">
        La rutina de servicio efectúa las operaciones apropiadas en la E/S para
        realizar la transferencia de datos solicitada.
      </p>
      <p class="text">
        Al finalizar la rutina de servicio se recupera el estado de la CPU y se
        continúa ejecutando el programa que se estaba ejecutando antes de la
        interrupción.
      </p>
      <p><br /></p>
      <p class="text"><b>Las interrupciones pueden ser:</b></p>
      <p class="text"></p>
      <ul class="indt">
        <li>ENMASCARABLES (se pueden dejar de atender por software)</li>
        <li>NO ENMASCARABLES (siempre atendidas)</li>
        <li>
          Dos formas de conocer la dirección/posición (vector) donde se
          encuentra la rutina de servicio de la interrupción
        </li>
        <li>
          Vector de interrupciones siempre FIJO ó el periférico suministra el
          vector de interrupción
        </li>
      </ul>
      <p><br /></p>
      <h1 id="1.2.3.4">1.2.3.4 Acceso directo a memoria</h1>
      <p class="text">
        El DMA (acceso directo a la memoria) permite que el dispositivo de red
        mueva los datos del paquete directamente a la memoria del sistema,
        reduciendo la utilización de la CPU. Sin embargo, la frecuencia y los
        intervalos aleatorios en los cuales los paquetes llegan no permiten que
        el sistema ingrese un estado de energía más bajo. El coalescentes DMA
        permite que el NIC recoja los paquetes antes de que inicie un evento
        DMA. Esto puede aumentar la latencia de la red, pero también aumenta las
        probabilidades de que el sistema consuma menos energía. Los adaptadores
        y dispositivos de red basados en el controlador Ethernet Intel® I350 (y
        controladores posteriores) Asistencia la fusión de DMA.
      </p>
      <p><br /></p>
      <p class="text">
        Los valores coalescentes más altos de DMA resultan en más energía
        guardada, pero pueden aumentar la latencia de red de su sistema. Si
        habilita la coalescación de DMA, también debe establecer la tasa de
        moderación de interrupciones en "mínimo". Esto minimiza el impacto de
        latencia impuesto por la coalescencia de DMA y da como resultado un
        mejor rendimiento de rendimiento de red máximo. Debe habilitar la
        coalescencia de DMA en todos los puertos activos del sistema. Usted no
        puede ganar ningún ahorro de energía si se habilita sólo en algunos de
        los puertos en su sistema. También hay varias configuraciones de BIOS,
        plataformas y aplicaciones que afectarán a su potencial ahorro
        energético.
      </p>
      <p><br /></p>
      <h1 id="1.2.3.5">1.2.3.5 Canales de E/S</h1>
      <p class="text">
        EL canal de E/S es una extensión del bus del 8088. Este canal contiene
        un bus de datos bidireccinal de 8 bits, 20 líneas de dirección, 6
        niveles de interrupción, líneas de control para las operaciones de
        lectura y escritura para la memoria y la E/S, líneas de control de 3
        canales de DMA, y líneas de control para el tiempo de refresco de
        memoria.
      </p>
      <p><br /></p>
      <img
        src="https://ordenadores-y-portatiles.com/wp-content/uploads/2020/05/DMA.jpg"
      />
      <p class="text">
        Los canales de E/S proporcionan una línea Ready para permitir
        operaciones con dispositivos de memoria o de E/S lentos. Cuando la línea
        no está activada por un dispositivo, el procesador genera ciclos de
        lectura y esritura a memoria que toman cuatro ciclos de 210 ns (esto es,
        840 ns) por byte. Todos los ciclos de lectura y escritura a E/S
        generados por el procesador requieren de cinco ciclos de 210 ns de reloj
        (1.05 ms) por byte. Todas las transferencias DMA requieren de cinco
        ciclos de reloj para un ciclo de tiempo de 1.05 ms por byte. Los ciclos
        de reloj se presentan aproximadamente cada 15 m sec y requieren de cinco
        ciclos de reloj.
      </p>
      <p><br /></p>
      <p class="text">
        Los dispositivos de E/S están direccionados utilizando un mapeo de E/S
        con el espacio de direccionamiento. El canal proporciona a las tarjetas
        de E/S 512 direcciones de dispositivos.
      </p>
      <p><br /></p>
      <h1 id="1.2.4">1.2.4 Buses</h1>
      <p class="text">
        En arquitectura de computadores, el bus es un sistema digital que
        transfiere datos entre los componentes de una computadora. Está formado
        por cables o pistas en un circuito impreso, dispositivos como resistores
        y condensadores, además de circuitos integrados.
      </p>
      <p><br /></p>
      <p class="text">
        Un bus es una trayectoria por la cual viajan los datos en una
        computadora para comunicar los distintos dispositivos entre sí. Los
        principales buses que se encuentran dentro de una PC son: los Buses del
        micro-procesador, los Buses de memoria y los Buses del sistema.
      </p>
      <p><br /></p>
      <h1 id="1.2.4.1">1.2.4.1 Tipos de buses</h1>
      <p class="text">
        <b>Existen dos tipos de transferencia en los buses:</b>
      </p>
      <ul class="indt">
        <li>
          Serie: El bus solamente es capaz de transferir los datos bit a bit. El
          bus tiene un único cable que transmite la información.
        </li>
        <li>
          Paralelo: El bus permite transferir varios bits simultáneamente, por
          ejemplo 8 bits.
        </li>
      </ul>
      <p><br /></p>
      <p class="text">
        Aunque en primera instancia parece mucho más eficiente la transferencia
        en paralelo, esta presenta inconvenientes:
      </p>
      <ul class="indt">
        <li>
          La frecuencia de reloj en el bus paralelo tiene que ser más reducida.
        </li>
        <li>
          La longitud de los cables que forman el bus está limitada por las
          posibles interferencias, el ruido y los retardos en la señal.
        </li>
      </ul>
      <p><br /></p>
      <p class="text">
        Además, los modernos buses serie están formados por varios canales: En
        este caso se transmite por varios buses serie simultáneamente.
      </p>
      <p><br /></p>
      <p class="text">
        En los primeros computadores electrónicos, era muy habitual encontrar
        buses paralelos, quedando los buses serie dedicados para funciones de
        menor entidad y dispositivos lentos, como el teclado. La tendencia en
        los últimos años es reemplazar los buses paralelos por buses serie (que
        suelen ser multicanal). Estos son más difíciles de implementar, pero
        están dejando velocidades de transferencia más elevadas, además de
        permitir longitudes de cable mayores.
      </p>
      <p><br /></p>
      <h1 id="1.2.4.3">1.2.4.3 Estructura de los buses</h1>
      <p class="text">
        Un bus es un medio compartido de comunicación constituido por un
        conjunto de líneas (conductores) que conecta las diferentes unidades de
        un computador. La principal función de un bus será, pues, servir de
        soporte para la realización de transferencias de información entre
        dichas unidades. La unidad que inicia y controla la transferencia se
        conoce como master del bus para dicha transferencia, y la unidad sobre
        la que se realiza la transferencia se conoce como slave. Los papeles de
        master y slave son dinámicos, de manera que una misma unidad puede
        realizar ambas funciones en transferencias diferentes. Por ejemplo, una
        unidad de DMA hace de slave en la inicialización que realiza el master,
        la CPU, para una operación de E/S. Sin embargo, cuando comienza la
        operación, la unidad de DMA juega el papel de master frente a la
        memoria, que en esta ocasión hace de slave.
      </p>
      <p><br /></p>
      <p class="text">
        Para garantizar el acceso ordenado al bus, existe un sistema de
        arbitraje, centralizado o distribuido, que establece las prioridades
        cuando dos o más unidades pretenden acceder al mismo tiempo al bus, es
        decir, garantiza que en cada momento sólo exista un master. Para
        establecer el tiempo de duración de las transferencias y que sea
        conocido tanto por el master como por el slave, un bus debe disponer de
        los medios necesarios para la sincronización master-slave.
      </p>
      <p><br /></p>
      <h1 id="1.2.4.4">1.2.4.4 Jerarquía de los buses</h1>
      <p class="text">
        Los computadores modernos tienen por lo menos 4 buses diferentes (bus
        interno, bus del procesador, bus del caché, bus de memoria, bus local de
        E/S, bus estándar de E/S). Se les considera una jerarquía, porque cada
        bus se conecta al nivel superior a él dentro del computador, integrando
        así todas las partes del computador. Cada uno es generalmente más lento
        que el que se encuentra sobre él, siendo el bus del procesador el más
        rápido tratándose de que este es el dispositivo más rápido del
        computador. Para mejorar el rendimiento del bus, las jerarquías de buses
        fueron implementadas cada vez más.
      </p>
      <p><br /></p>
      <h1>1.2.5 Interrupciones</h1>
      <p>
        La CPU desvía su atención de la tarea actual, que se esta ejecutando,
        hacia algún problema que requiere su atención, el tipo específico de
        interrupción causado por entrada/salida y otras unidades de hardware.
      </p>
      <p><br /></p>
      <!-- Unidad 2  -->
      <h3>UNIDAD 2</h3>
      <a href="#2.1"><li>2.1 Organización del Procesador</li></a>
      <a href="#2.1"><li>Estructuras de Registros</li></a>
      <ul>
        <a href="#2.2.1"
          ><li class="indt">2.2.1 Registros Visibles Para el Usuario</li></a
        >
        <a href="#2.2.2"
          ><li class="indt">2.2.2 Registros de Control y de Estados</li></a
        >
      </ul>
      <a href="#2.3"><li>2.3 El Ciclón de Instrucciones</li></a>
      <ul>
        <a href="#2.3.1"
          ><li class="indt">2.3.1 Ciclo Fetch-Decode-Execute</li></a
        >
        <a href="#2.3.2"
          ><li class="indt">2.3.2 Segmentación de Instrucciones</li></a
        >
        <a href="#2.3.3"
          ><li class="indt">2.3.3 Conjunto de Instrucciones</li></a
        >
      </ul>
      <a href="#2.4"><li>2.4 Modos de Direccionamiento</li></a>
      <div class="unidad2">
        <i class="fab fa-angular"></i>
        <h3>UNIDAD 2</h3>
        <h2 id="2.1">2.1 Organización del Procesador</h2>
        <hr />
        <p class="text">
          La Unidad de Procesamiento (CPU) controla el funcionamiento del
          computador y lleva a cabo sus funciones de procesamiento de datos.
          Frecuentemente se le llama procesador.
        </p>
        <p><br /></p>
        <p class="text">
          Un procesador, incluye tanto registros visibles por el usuario como
          registros de control/estado. <br />
          Los registros visibles por el usuario pueden ser de uso general o
          tener una utilidad especial, mientras que los registros de control y
          estado se usan para controlar el funcionamiento del procesador, un
          claro ejemplo es el contador de programa.
        </p>
        <p><br /></p>
        <p class="text"><b>Lleva a cabo una gran variedad de </b></p>
        <ul class="indt">
          <li><b>Cálculos</b></li>
          <li><b>Comparaciones numéricas</b></li>
          <li>
            <b
              >Transferencias de datos como respuesta a las peticiones de los
              programas que están siendo ejecutados en memoria.</b
            >
          </li>
        </ul>
        <b></b>
        <p><br /></p>
        <p>
          <img
            src="https://0901.static.prezi.com/preview/v2/ley2tvplyqic3xcsvltnh3i7th6jc3sachvcdoaizecfr3dnitcq_3_0.png"
          /><br />
        </p>
        <h2 id="2.2">2.2 Estructuras de Registros</h2>
        <hr />
        <h4><i> Registros del CPU </i></h4>
        <p class="text">
          Se emplean para controlar las instrucciones en ejecución, manejar
          direccionamiento de memoria y propiciar la capacidad aritmética.
        </p>
        <p><br /></p>
        <p class="text">
          Los registros vienen de tres tipos: datos, direcciones e índice, que
          tiene lugar en casi todos los aspectos de la operación del CPU.
        </p>
        <p><br /></p>
        <p class="text">
          El tamaño de un registro depende del CPU; los más simples tienen
          registros que aceptan 8 o 16 bits de datos y los más complejos tienen
          registros de 32, 48 o 64 bits.
        </p>
        <p><br /></p>
        <h1 id="2.2.1">2.2.1 Registros Visibles Para el Usuario</h1>
        <p class="text">
          Un registro visible al usuario es aquél que puede ser referenciado por
          medio del lenguaje máquina que ejecuta la CPU. Prácticamente todos los
          diseños contemporáneos de CPUs están provistos de varios registros
          visibles al usuario, en oposición a disponer de un único acumulador.
        </p>
        <p><br /></p>
        <p class="text"><b>Podemos clasificarlos en:</b></p>
        <ul class="indt">
          <li>Uso General</li>
          <li>Datos</li>
          <li>Direcciones</li>
          <li>Códigos de Condición</li>
        </ul>
        <p><br /></p>
        <p class="text">
          Los registros de uso general pueden ser asignados por el programador a
          diversas funciones. A veces, su uso dentro del repertorio de
          instrucciones es para contener el operando para cualquier código de
          operación. <br />
          Esto proporciona una utilización de registros de auténtico uso
          general. Con frecuencia, sin embargo, existen restricciones. Por
          ejemplo, puede haber registros específicos para operaciones en coma
          flotante.
        </p>
        <p><br /></p>
        <p class="text">
          En algunos casos los registros de uso general pueden ser utilizados
          para funciones de direccionamiento. En otros casos hay una separación
          clara o parcial entre registros de datos y registros de direcciones.
          <br />
          Los registros de datos pueden ser usados únicamente para contener
          datos y no se pueden emplear en el cálculo de una dirección de
          operando.
        </p>
        <p><br /></p>
        <p class="text">
          Los registros de dirección pueden ser en sí registros de uso más o
          menos general, o pueden estar dedicados a un modo de direccionamiento
          particular. El caso más conocido es el puntero a pila. La cantidad de
          registros generales o especializados es una cuestión de diseño. No hay
          solución óptima, pero la tendencia parece ir hacia el uso de registros
          especializados. <br />
          Otro problema de diseño es el numero de registros, de uso general o de
          datos más direcciones, que tienen que incluirse.
        </p>
        <p><br /></p>
        <p class="text">
          A mayor cantidad de registros se requieren mayor cantidad de bits en
          el campo de operando. Parece óptimo entre 8 y 32 registros. Menos
          registros se traducen en más referencias a memoria; más registros no
          reducen notablemente las referencias a memoria. Por último, está la
          cuestión de la longitud de los registros.
        </p>
        <p><br /></p>
        <p class="text">
          Los registros que han de contener direcciones han de ser lo
          suficientemente grandes como para albergar la dirección más grande.
          Los registros de datos deben ser capaces de contener valores de la
          mayoría de tipos de datos. <br />
          Algunas máquinas permiten que los registros contiguos sean usados como
          uno para contener valores de doble longitud.
        </p>
        <p><br /></p>
        <p class="text">
          Una categoría final de registros, que es al menos parcialmente visible
          al usuario, contiene códigos de condición (también llamados
          indicadores o flags). <br />
          Los códigos de condición son bits fijados por el hardware de la CPU
          como resultado de alguna operación. Por ejemplo, una operación
          aritmética puede producir un resultado positivo, negativo o nulo, o
          con desbordamiento. Además de almacenarse el propio resultado en un
          registro o en la memoria, se obtiene también un código de condición.
        </p>
        <p><br /></p>
        <p class="text">
          Los bits de códigos de condición se reúnen en uno o más registros. Por
          lo general, forman parte de un registro de control. <br />
          Comúnmente, las instrucciones de máquina permiten que estos bits sean
          leídos por referencia implícita, pero no pueden ser alterados por el
          programador.
        </p>
        <p><br /></p>
        <h1 id="2.2.2">2.2.2 Registros de Control y de Estados</h1>
        <h4><i> Registros de control </i></h4>
        <p class="text">
          Hay diversos registros de la CPU que se pueden emplear para controlar
          su funcionamiento. La mayoría de éstos, en la mayor parte de las
          máquinas, no son visibles al usuario. Algunos de ellos pueden ser
          visibles a instrucciones de máquina ejecutadas en un modo de control o
          de sistema operativo.
        </p>
        <p><br /></p>
        <p class="text">
          Naturalmente, máquinas diferentes tendrán diferentes organizaciones de
          registros y usará distinta terminología. Se enumera aquí una lista
          razonablemente completa de tipos de registros, con una breve
          descripción. Son esenciales cuatro registros para la ejecución de una
          instrucción: el contador de programa, el registro de dirección, el
          registro de instrucción y el registro de datos.
        </p>
        <p><br /></p>
        <p class="text">
          El contador de programa contiene una dirección de instrucción.
          Típicamente, la CPU actualiza el PC después de cada captación de
          instrucción de manera que siempre apunta a la siguiente instrucción a
          ejecutar. Una instrucción de bifurcación o salto también modificará el
          contenido de PC. La instrucción captada se carga en el registro de
          instrucción, donde son analizados el código de operación y los campos
          de operando. <br />
          Se intercambian datos con la memoria por medio de registro de
          direcciones y el de datos. En un sistema con organización de bus, el
          de direcciones se conecta directamente al bus de direcciones, y el de
          datos directamente al bus de datos.
        </p>
        <p><br /></p>
        <p class="text">
          Los registros visibles al usuario, sucesivamente, intercambian datos
          con el de datos. Los cuatro registros que acaban de mencionar se usan
          para la transferencia de datos entre la CPU y la memoria. Dentro de la
          CPU, los datos tienen que ofrecerse a la ALU para su procesamiento. La
          ALU puede tener acceso directo al de datos y a los registros visibles
          al usuario. Como alternativa, puede haber registros intermedios
          adicionales en el límite de la ALU; estos registros sirven como
          registros de entrada y salida de la ALU e intercambian datos con el de
          datos y los registros visibles al usuario.
        </p>
        <p><br /></p>
        <h4><i> Registros de estado</i></h4>
        <p class="text">
          El registro de estado, también conocido como registro de bandera,
          palabra de estado del programa y registro de código de condición, se
          define como un conjunto de bits de bandera dentro de un procesador.
        </p>
        <p><br /></p>
        <p class="text">
          Un registro es un circuito procesador y es muy parecido a una
          ubicación de memoria, lo que significa que los datos podrían
          escribirse y leerse. A diferencia de una ubicación de memoria, el
          registro de estado a menudo no tiene una dirección porque el
          microprocesador la usa internamente. En una unidad central de
          procesamiento (CPU) de 8 bits, se puede establecer un bit de registro
          de estado, igual al número 1, o borrar , igual al número 0, mediante
          una variedad de resultados de operación del procesador. El procesador
          a veces establece o borra los bits, pero otras veces, una instrucción
          de programa particular establece o borra los bits.
        </p>
        <p><br /></p>
        <p class="text">
          Los bits de registro de estado también se denominan banderas o bits de
          bandera, y el programador los utiliza para ciertos fines de
          programación. Cada bandera en un registro de estado tiene un propósito
          único. <br />
          El indicador de acarreo se establece si una operación anterior hizo
          que el séptimo bit - o indicador negativo - se desbordara, o hiciera
          que el indicador de transporte se desbordara. Se establece durante los
          cambios de lógica, comparación y aritmética. El indicador de cero se
          establece si el resultado de la operación más reciente fue 0.
        </p>
        <p><br /></p>
        <p class="text">
          Un indicador llamado "deshabilitar interrupción" funciona permitiendo
          o deshabilitando la operación de interrupciones, que son instrucciones
          que detienen temporalmente ciertas operaciones para que se puedan
          realizar otras operaciones. Cuando se establece este indicador en
          particular, no se permite que funcionen las interrupciones, pero
          cuando está claro, se permiten las interrupciones. Otra bandera
          llamada bandera decimal permite al procesador seguir un modo binario
          más avanzado para realizar ecuaciones aritméticas impecables. Cuando
          se establece la bandera, utiliza este modo binario avanzado. Otro bit
          de registro es el bit de interrupción, que se establece cuando se
          ejecuta el comando Force Interrupt (BRK).
        </p>
        <p><br /></p>
        <h2 id="2.3">2.3 El Ciclón de Instrucciones</h2>
        <hr />
        <h4><i> Ciclos de computadora </i></h4>
        <p class="text">
          La búsqueda es el proceso de obtener instrucciones de un programa o un
          elemento de datos de la memoria. El término decodificar se refiere al
          proceso de traducir las instrucciones a señales que la computadora
          puede ejecutar. <br />
          Ejecutar es el proceso de llevar a cabo los comandos. Almacenamiento
          en este contexto significa escribir el resultado a la memoria. <br />
        </p>
        <p><br /></p>
        <p class="text">
          En algunas computadoras, el procesador busca, decodifica, ejecuta y
          almacena solo una instrucción a la vez. En estas computadoras el
          procesador espera hasta que una instrucción completa las cuatro etapas
          del ciclo antes de iniciar a trabajar con la siguiente instrucción.
        </p>
        <p><br /></p>
        <p class="text">
          Hoy día la mayoría de las computadoras personales soportan un concepto
          llamado pipelining: <br />
          Con pipelining los procesadores inician la búsqueda de una segunda
          instrucción antes de que se haya completado el ciclo de la computadora
          de la primera instrucción. Los procesadores que cuentan con pipelining
          habilitado son más rápidos en el procesamiento porque no tienen que
          esperar para que una instrucción complete el ciclo de computadora
          antes de buscar la siguiente.
        </p>
        <p><br /></p>
        <h1 id="2.3.1">2.3.1 Ciclo Fetch-Decode-Execute</h1>
        <p class="text">
          El encargado de ejecutar un programa en una computadora u otro sistema
          computacional es el CPU, lo realiza siguiendo el llamado ciclo Fetch
          Decode Execute, con este ciclo se ejecutan todas las tareas que una
          computadora puede realizar.<br />
          Este ciclo tiene algunas variantes y conforme ha avanzado el tiempo y
          la tecnología ha sufrido algunos cambios, pero el ciclo básico se
          conforma de las siguientes etapas:
        </p>
        <p><br /></p>
        <p class="text"></p>
        <ul class="indt">
          <li>
            Traer la instrucción: Se obtiene la instrucción desde memoria y se
            almacena en el registro del CPU para instrucciones.
          </li>
          <li>
            Decodificar la instrucción: Se identifica el modo de
            direccionamiento de la instrucción y la ubicación de los datos a
            tratar, ya sea de
          </li>
          <li>memoria, registro o instrucción directamente.</li>
          <li>
            Carga de Parámetros: Se ejecuta la lectura, cargando todos los datos
            identificados en el paso anterior.
          </li>
          <li>
            Ejecutar: Se ejecuta la instrucción ya configurada, realiza la tarea
            indicada, ya sea una suma, resta, almacenar información, extraer
          </li>
          <li>información etc.</li>
          <li>
            Almacenar: Se almacena el resultado obtenido de ejecutar la
            instrucción, por ejemplo, el resultado de una suma o un índice
            (Número)
          </li>
          <li>
            como resultado de éxito de almacenar u obtener información de un
            archivo, entre otros.
          </li>
          <li>
            Actualizar PC: Esta etapa es la de actualizar el registro PC
            (Program Counter) que contiene la siguiente dirección a ejecutar.
          </li>
        </ul>
        <p><br /></p>
        <p class="text">
          Evidentemente al ser un ciclo estas etapas se repiten constantemente
          durante el funcionamiento de la computadora.
        </p>
        <p><br /></p>
        <p class="text">
          Se debe considerar que el ciclo expuesto anteriormente es muy básico.
          Como se mencionaba hoy en día estos ciclos han tenido algunas
          alteraciones y optimizado de gran manera, como se sabe los sistemas de
          hoy en día son multitareas, lo cual conlleva a una alteración en este
          ciclo, además de las diferentes técnicas para reducir el tiempo de
          ejecución de instrucciones con temas de concurrencia y paralelismo en
          los procesadores modernos.
        </p>
        <p><br /></p>
        <p class="text">
          El ciclo expuesto nos muestra un poco la forma en la que las
          computadoras funcionan, todo el proceso que conlleva ejecutar una
          instrucción que puede parecer muy simple, además este ciclo básico
          permite darse una idea de cómo ha evolucionado los procesadores y las
          técnicas para reducir el tiempo de ejecución dado que los sistemas
          actuales ejecutan de forma simultánea muchas veces este ciclo, siendo
          este modificado y más eficiente.
        </p>
        <p><br /></p>
        <h1 id="2.3.2">2.3.2 Segmentación de Instrucciones</h1>
        <p class="text">
          La segmentación (en inglés pipelining, literalmente 'tubería' o
          'cañería', o data pipeline)​ es un método por el cual se consigue
          aumentar el rendimiento de algunos sistemas electrónicos digitales. Se
          usa principalmente en los microprocesadores.
        </p>
        <p><br /></p>
        <p class="text">
          El nombre, por analogía, viene de que para impulsar el gas en un
          oleoducto a la máxima velocidad posible es necesario dividir el
          oleoducto en tramos y colocar una bomba que dé un nuevo impulso al
          gas.
        </p>
        <p><br /></p>
        <p class="text">
          El símil con la programación existe en que los cálculos deben ser
          registrados o sincronizados con el reloj cada cierto tiempo para que
          la ruta crítica (tramo con más carga o retardo computacional entre dos
          registros de reloj) se reduzca. <br />
        </p>
        <p><br /></p>
        <p class="text">
          La ruta crítica es en realidad la frecuencia máxima de trabajo
          alcanzada por el conjunto. A mayor ruta crítica (tiempo o retraso
          entre registros) menor es la frecuencia máxima de trabajo y a menor
          ruta crítica mayor frecuencia de trabajo. La una es la inversa de la
          otra. Repartir o segmentar equitativamente el cálculo hace que esa
          frecuencia sea la óptima a costa de más área para el almacenamiento o
          registro de los datos intervinientes y de un retraso o latencia (en
          ciclos de reloj/tiempo) en la salida del resultado equivalente al
          número de segmentaciones o registros realizados.
        </p>
        <p><br /></p>
        <p class="text">
          La ventaja primordial de este sistema es que, tal y como se muestra en
          la imagen, una vez el canal (pipe) está lleno, es decir, después de
          una latencia de cuatro en la imagen, los resultados de cada comando
          vienen uno tras otro cada flanco de reloj y sin latencia extra por
          estar encadenados dentro del mismo canal. Todo esto habiendo
          maximizado la frecuencia máxima de trabajo.
        </p>
        <p><br /></p>
        <h1 id="2.3.3">2.3.3 Conjunto de Instrucciones</h1>
        <p class="text">
          Un conjunto de instrucciones o repertorio de instrucciones, juego de
          instrucciones o ISA (del inglés Instruction Set Architecture,
          Arquitectura del Conjunto de Instrucciones) es una especificación que
          detalla las instrucciones que una CPU de un ordenador puede entender y
          ejecutar, o el conjunto de todos los comandos implementados por un
          diseño particular de una CPU.
        </p>
        <p><br /></p>
        <p class="text">
          El término describe los aspectos del procesador generalmente visibles
          a un programador, incluyendo los tipos de datos nativos, las
          instrucciones, los registros, la arquitectura de memoria y las
          interrupciones, entre otros aspectos.
        </p>
        <p><br /></p>
        <p class="text">
          Existe principalmente de 3 tipos: CISC (Complex Instruction Set
          Computer), RISC (Reduced Instruction Set Computer) y SISC (Specific
          Instruction Set Computer).
        </p>
        <p><br /></p>
        <p class="text">
          La arquitectura del conjunto de instrucciones (ISA) se emplea a veces
          para distinguir este conjunto de características de la
          microarquitectura, que son los elementos y técnicas que se emplean
          para implementar el conjunto de instrucciones. Entre estos elementos
          se encuentras las microinstrucciones y los sistemas de caché. <br />
          Procesadores con diferentes diseños internos pueden compartir un
          conjunto de instrucciones; por ejemplo el Intel Pentium y AMD Athlon
          implementan versiones casi idénticas del conjunto de instrucciones
          x86, aunque tienen diseños internos completamente opuestos.
        </p>
        <p><br /></p>
        <p>
          <img src="https://i.gyazo.com/17aceb32ac7a220d1ff1db16cb6d6a22.png" />
          <br />
        </p>
        <h2 id="2.4">2.4 Modos de Direccionamiento</h2>
        <hr />
        <p class="text">
          En informática, los modos de direccionamiento son las diferentes
          maneras de especificar un operando dentro de una instrucción en
          lenguaje ensamblador.
        </p>
        <p><br /></p>
        <p class="text">
          Un modo de direccionamiento especifica la forma de calcular la
          dirección de memoria efectiva de un operando mediante el uso de la
          información contenida en registros y/o constantes, contenida dentro de
          una instrucción de la máquina o en otra parte.
        </p>
        <p><br /></p>
        <p class="text">
          No existe una forma generalmente aceptada de nombrar a los distintos
          modos de direccionamiento. En particular, los distintos autores y
          fabricantes de equipos pueden dar nombres diferentes para el modo de
          hacer frente al mismo, o los mismos nombres, a los diferentes modos de
          direccionamiento.
        </p>
        <p><br /></p>
        <p class="text">
          Además, un modo de direccionamiento que en una determinada
          arquitectura se trata como un modo de direccionamiento, puede
          representar la funcionalidad que en otra arquitectura está cubierto
          por dos o más modos de direccionamiento.
        </p>
        <p><br /></p>
      </div>
      <!-- Unidad 3 -->
      <h3>UNIDAD 3</h3>
      <a href="#3.1"><li>3.1 ChipSet.</li></a>
      <ul>
        <a href="#3.1.1"
          ><li class="indt">3.1.1 Unidad Central de Procesamiento (CPU)</li></a
        >
        <a href="#3.1.2"><li class="indt">3.1.2 Cotrolador del Bus</li></a>
        <a href="#3.1.3"
          ><li class="indt">3.1.3 Puertas de Entrada Salida E/S</li></a
        >
        <a href="#3.1.4"
          ><li class="indt">3.1.4 Controlador de Interruptores</li></a
        >
        <a href="#3.1.5"
          ><li class="indt">
            3.1.5 Controlador de Acceso Directo a Memoria
          </li></a
        >
        <a href="#3.1.6"
          ><li class="indt">3.1.6 Circuitos de Temporización</li></a
        >
        <a href="#3.1.7"><li class="indt">3.1.7 Circuitos de Control</li></a>
        <a href="#3.1.8"><li class="indt">3.1.8 Controladores de Video</li></a>
      </ul>
      <a href="#3.2"><li>3.2 Aplicaciones</li></a>
      <ul>
        <a href="#3.2.1"><li class="indt">3.2.1 Entrada/Salida</li></a>
        <a href="#3.2.2"><li class="indt">3.2.2 Almacenamiento</li></a>
        <a href="#3.2.3"><li class="indt">3.2.3 Fuentes de Alimentación</li></a>
      </ul>
      <a href="#3.3"><li>3.3 Ambientes de Servicio</li></a>
      <ul>
        <a href="#3.3.1"><li class="indt">3.3.1 Negocios</li></a>
        <a href="#3.3.2"><li class="indt">3.3.2 Industria</li></a>
        <a href="#3.3.3"><li class="indt">3.3.3 Comertio Electrónico</li></a>
      </ul>
      <div class="unidad3">
        <i class="fab fa-angular"></i>
        <h3>UNIDAD 3</h3>
        <h2 id="3.1">3.1 Chipset</h2>
        <hr />
        <p class="text">
          Un chipset es el conjunto de circuitos integrados diseñados con base
          en la arquitectura de un procesador (en algunos casos, diseñados como
          parte integral de esa arquitectura), permitiendo que ese tipo de
          procesadores funcionen en una placa base. Sirven de puente de
          comunicación con el resto de componentes de la placa, como son la
          memoria, las tarjetas de expansión, los puertos USB, ratón, teclado,
          etc.
        </p>
        <p><br /></p>
        <p>
          <img
            src="https://d22k5h68hofcrd.cloudfront.net/magefan_blog/Que_es_un_chipset.jpg"
          /><br />
        </p>
        <p class="text">
          Las placas base modernas suelen incluir dos integrados, denominados
          puente norte y puente sur, y suelen ser los circuitos integrados más
          grandes después de la GPU y el microprocesador. Las últimas placa base
          carecen de puente norte, ya que los procesadores de última generación
          lo llevan integrado.
        </p>
        <p><br /></p>
        <p class="text"><b>Funcionamiento:</b></p>
        <p><br /></p>
        <p class="text">
          El chipset es el que hace posible que la placa base funcione como eje
          del sistema, dando soporte a varios componentes e interconectándolos
          de forma que se comuniquen entre ellos haciendo uso de diversos buses.
          Es uno de los pocos elementos que tiene conexión directa con el
          procesador, gestiona la mayor parte de la información que entra y sale
          por el bus principal del procesador, del sistema de vídeo y muchas
          veces de la memoria RAM. En el caso de los computadores PC, es un
          esquema de arquitectura abierta que establece modularidad: el chipset
          debe tener interfaces estándar para los demás dispositivos. Esto
          permite escoger entre varios dispositivos estándar, por ejemplo, en el
          caso de los buses de expansión, algunas tarjetas madre pueden tener
          bus PCI-Express y soportar diversos tipos de tarjetas de distintos
          anchos de bus (1x, 8x, 16x).
        </p>
        <p><br /></p>
        <h1 id="3.1.1">3.1.1 Unidad Central de Procesamiento</h1>
        <p class="text">
          La unidad central de procesamiento (siglas en inglés Central
          Processing Unit) es el hardware dentro de una computadora u otros
          dispositivos programables. Su trabajo es interpretar las instrucciones
          de un programa informático mediante la realización de las operaciones
          básicas aritméticas, lógicas y externas (provenientes de la unidad de
          entrada/salida). Su diseño y avance ha variado notablemente desde su
          creación, aumentando su eficiencia y potencia, y reduciendo aspectos
          como el consumo de energía y el costo.
        </p>
        <p><br /></p>
        <p class="text"><b>Los componentes de la CPU son: </b></p>
        <ul class="indt">
          <li>
            <b
              >Unidad aritmético lógica (ALU): Realiza operaciones aritméticas y
              lógicas.</b
            >
          </li>
          <li>
            <b
              >Unidad de control (CU): Dirige el tráfico de información entre
              los registros de la CPU y conecta con la ALU las instrucciones
              extraídas
            </b>
          </li>
          <li><b>de la memoria.</b></li>
          <li>
            <b
              >Registros internos: No accesibles (de instrucción, de bus de
              datos y bus de dirección) y accesibles de uso específico (contador
              programa,</b
            >
          </li>
          <li>
            <b>puntero pila, acumulador, flags, etc.) o de uso general.</b>
          </li>
        </ul>
        <b></b>
        <p><br /></p>
        <h1 id="3.1.2">3.1.2 Controlador del Bus</h1>
        <p class="text">
          El controlador del bus se encarga de la frecuencia de funcionamiento y
          las señales de sincronismo, temporización y control. Está ubicado en
          un chip en la placa base.
        </p>
        <p><br /></p>
        <p class="text">
          El bus es la vía a través de la que se van a transmitir y recibir
          todas las comunicaciones, tanto internas como externas, del sistema
          informático. El bus es solamente un dispositivo de transferencia de
          información entre los componentes conectados a él, no almacena
          información alguna en ningún momento. Los datos, en forma de señal
          eléctrica, sólo permanecen en el bus el tiempo que necesitan en
          recorrer la distancia entre los dos componentes implicados en la
          transferencia.
        </p>
        <p><br /></p>
        <p class="text">Bus de Datos:</p>
        <p class="text">
          El bus de datos es el medio por el que se transmite la instrucción o
          dato apuntado por el bus de direcciones. Es usado para realizar el
          intercambio de instrucciones y datos tanto internamente, entre los
          diferentes componentes del sistema informático, como externamente,
          entre el sistema informático y los diferentes subsistemas periféricos
          que se encuentran en el exterior, una de las características
          principales de una computadora es el número de bits que puede
          transferir el bus de datos (16, 32, 64, etc.). Cuanto mayor sea este
          número, mayor será la cantidad de información que se puede manejar al
          mismo tiempo.
        </p>
        <p><br /></p>
        <p class="text">Bus de Control:</p>
        <p class="text">
          Es un número variable de líneas a través de las que se controlan las
          unidades complementarías. El número de líneas de control dependerá
          directamente de la cantidad que pueda soportar el tipo de CPU
          utilizada y de su capacidad de direccionamiento de información.
        </p>
        <p><br /></p>
        <h1 id="3.1.3">3.1.3 Puertas de Entrada Salida E/S</h1>
        <p class="text">
          Un puerto de E/S es un enchufe en una computadora al que se conecta un
          cable. El puerto conecta la CPU a un dispositivo periférico a través
          de una interfaz de hardware o a la red a través de una interfaz de
          red.
        </p>
        <p><br /></p>
        <p class="text">
          En otras palabras, un puerto de E/S es un punto de conexión que actúa
          como interfaz entre la computadora y dispositivos externos como mouse,
          impresora, módem, etc. Estos son de dos tipos:
        </p>
        <ul class="indt">
          <li>
            Puerto interno: Conecta la placa base a dispositivos internos como
            unidad de disco duro, unidad de CD, módem interno, etc.
          </li>
          <li>
            Puerto externo: Conecta la placa base a dispositivos externos como
            módem, mouse, impresora, unidades flash, etc.
          </li>
        </ul>
        <p><br /></p>
        <p class="text"><b>Tipos de puertos:</b></p>
        <p><br /></p>
        <p class="text">
          Puerto serial: Los puertos seriales transmiten datos secuencialmente
          un bit a la vez. Por lo tanto, solo necesitan un cable para transmitir
          8 bits. Sin embargo, también los hace más lentos. Los puertos serie
          suelen ser conectores macho de 9 o 25 pines. También se conocen como
          puertos COM (comunicación) o puertos RS323C.
        </p>
        <p><br /></p>
        <p>
          <img
            src="https://img-17.ccm2.net/BrYIp3V40N-zO6ASFn6pNQC70Wg=/500x/6749bf9fb276462383b40df8b1a109bb/ccm-encyclopedia/Puerto_serial_y_puerto_paralelo.jpg"
          /><br />
        </p>
        <p class="text">
          Puerto USB: USB son las siglas de Universal Serial Bus. Es el estándar
          de la industria para la conexión de datos digitales de corta
          distancia. El puerto USB es un puerto estandarizado para conectar una
          variedad de dispositivos como impresora, cámara, teclado, altavoz,
          etc.
        </p>
        <p><br /></p>
        <p class="text">
          Puerto PS/2: PS/2 son las siglas de Personal System/2. Es un puerto
          estándar hembra de 6 pines que se conecta al cable mini-DIN macho. IBM
          introdujo PS/2 para conectar el mouse y el teclado a las computadoras
          personales. Este puerto ahora está casi obsoleto, aunque algunos
          sistemas compatibles con IBM pueden tener este puerto.
        </p>
        <p><br /></p>
        <p class="text">
          Puerto de infrarrojos: El puerto de infrarrojos es un puerto que
          permite el intercambio inalámbrico de datos en un radio de 10 m. Dos
          dispositivos que tienen puertos infrarrojos se colocan uno frente al
          otro para que los haces de luces infrarrojas se puedan utilizar para
          compartir datos.
        </p>
        <p><br /></p>
        <p class="text">
          Puerto Bluetooth: Bluetooth es una especificación de
          telecomunicaciones que facilita la conexión inalámbrica entre
          teléfonos, computadoras y otros dispositivos digitales a través de una
          conexión inalámbrica de corto alcance. El puerto Bluetooth permite la
          sincronización entre dispositivos habilitados para Bluetooth.
        </p>
        <p><br /></p>
        <p class="text">
          Puerto FireWire: FireWire es el estándar de interfaz de Apple Computer
          para permitir la comunicación de alta velocidad mediante bus serie.
          También se llama IEEE 1394 y se usa principalmente para dispositivos
          de audio y video como videocámaras digitales.
        </p>
        <p><br /></p>
        <h1 id="3.1.4">3.1.4 Controlador de Interruptores</h1>
        <p class="text">
          El controlador de interrupciones es un módulo que tiene por función
          gestionar las interrupciones de entrada/salida para el procesador.
          Esto ahorra diseñar lógica y añadir patitas al procesador. También
          proporciona flexibilidad porque permite idealmente, gestionar un
          número ilimitado señales de interrupción (favoreciendo la expansión
          del sistema de entrada/salida).
        </p>
        <p><br /></p>
        <p class="text">
          El controlador recibe el conjunto de señales de interrupción
          procedentes de los dispositivos, toma la decisión de cuál es la más
          prioritaria, y envía una única señal al procesador. La respuesta del
          procesador es transmitida al dispositivo y el propio controlador se
          encarga de depositar en el bus el vector de la interrupción.
        </p>
        <p><br /></p>
        <p class="text"><b>Ciclo de reconocimiento de interrupción</b></p>
        <ul class="indt">
          <li>
            Tras la activación de una línea IR, el controlador activa la salida
            INTR señalándole a la CPU la existencia de una interrupción
            activada.
          </li>
          <li>
            Al recibir la señal, el procesador da un pulso en su salida INTA
            indicando que comienza un ciclo de reconocimiento de interrupción.
          </li>
          <li>
            Al recibir el controlador el pulso por su entrada INTA comienza a
            arbitrar las interrupciones recibidas y selecciona la más
            prioritaria.
          </li>
          <li>
            Se emite un segundo pulso por la línea INTA del procesador (o
            controlador de bus) que utiliza el controlador para depositar en el
            bus el
          </li>
          <li>vector correspondiente a la interrupción de mayor prioridad.</li>
          <li>
            El procesador obtiene la dirección de la rutina de interrupción a
            partir de este dato y salta a ella. Almacena el registro de flags y
            la
          </li>
          <li>
            dirección de retorno, deshabilita las interrupciones y comienza a
            ejecutar la rutina.
          </li>
        </ul>
        <p><br /></p>
        <h1 id="3.1.5">3.1.5 Controlador de Acceso Directo a Memoria (DMA)</h1>
        <p class="text">
          El mecanismo de acceso directo a memoria está controlado por un chip
          específico, el DMAC ("DMA Controller"), que permite realizar estos
          intercambios sin apenas intervención del procesador. En los XT estaba
          integrado en un chip 8237A que proporcionaba 4 canales de 8 bits
          (puede mover solo 1 Byte cada vez); sus direcciones de puerto son
          000–00Fh. Posteriormente en los AT se instalaron dos de estos
          integrados y las correspondientes líneas auxiliares en el bus de
          control.
        </p>
        <p><br /></p>
        <p>
          <img
            src="https://i.pcmag.com/imagery/encyclopedia-terms/dma-dmapio.fit_lim.size_1050x.gif"
          /><br />
        </p>
        <p class="text">
          En contra de lo que podría parecer, el resultado no fue disponer de 8
          canales, porque el segundo controlador se colgó en “Cascada” de la
          línea 4 del primero. Los canales del segundo DMAC está asignado a las
          direcciones 0C0–0DFh y son de 16 bits.
        </p>
        <p><br /></p>
        <p class="text">
          Pueden mover 2 Bytes (de posiciones contiguas) cada vez. Cada canal
          tiene asignada una prioridad para el caso de recibirse simultáneamente
          varias peticiones (los números más bajos tienen prioridad más alta).
        </p>
        <p><br /></p>
        <p class="text">
          Pueden ser utilizados por cualquier dispositivo que los necesite
          (suponiendo naturalmente que esté diseñado para soportar este modo de
          operación). Cada sistema los asigna de forma arbitraria, pero hay
          algunos cuya asignación es estándar.
        </p>
        <p><br /></p>
        <h1 id="3.1.6">3.1.6 Circuitos de Temporización</h1>
        <p class="text">
          El circuito electrónico que más se utiliza tanto en la industria como
          en circuitería comercial, es el circuito temporizador o de retardo,
          dentro de la categoría de temporizadores, cabe destacar el más
          económico y también menos preciso consistente en una resistencia y un
          condensador, a partir de aquí se puede contar con un sinfín de
          opciones.
        </p>
        <p><br /></p>
        <p class="text">
          Un temporizador básicamente consiste en un elemento que se activa o
          desactiva después de un tiempo preestablecido. De esta manera podemos
          determinar el parámetro relacionado con el tiempo que ha de
          transcurrir para que el circuito susceptible de temporizarse, se
          detenga o empiece a funcionar o simplemente cierre un contacto o lo
          abra.
        </p>
        <p><br /></p>
        <p class="text">
          Se encuentra en la placa base de la PC y que es capaz de mantener una
          cuenta de tiempo basada en el reloj de la computadora. Puede usarse
          para calcular el intervalo entre dos mediciones de tiempo o para
          generar pausas. Este chip tiene la capacidad de realizar diferentes
          funciones de conteo. Es útil para medir el tiempo que dura cierto
          proceso o para mantener actualizadas la hora del día y la fecha si se
          deja la PC conectada y encendida.
        </p>
        <p><br /></p>
        <h1 id="3.1.7">3.1.7 Circuitos de Control</h1>
        <p class="text">
          Es una red secuencial que acepta un código que define la operación que
          se va a ejecutar y luego prosigue a través de una secuencia de
          estados, generando una correspondiente secuencia de señales control.
        </p>
        <p><br /></p>
        <p class="text">
          Estas señales de control incluyen el control de lectura-escritura y
          señales de dirección de memoria válida en el bus de control del
          sistema. Otras señales generadas por el controlador se conectan a la
          ALU y a los registros internos del procesador para regular el flujo de
          información en el procesador y desde los buses de dirección y de datos
          del sistema.
        </p>
        <p><br /></p>
        <h1 id="3.1.8">3.1.8 Controladores de Video</h1>
        <p class="text">
          La tarjeta de video, (también llamada controlador de video), es un
          componente electrónico requerido para generar una señal de video que
          se manda a una pantalla de video por medio de un cable. La tarjeta de
          video se encuentra normalmente en la placa de sistema de la
          computadora o en una placa de expansión. La tarjeta gráfica reúne toda
          la información que debe visualizarse en pantalla y actúa como interfaz
          entre el procesador y el monitor; la información es enviada a éste por
          la placa luego de haberla recibido a través del sistema de buses.
        </p>
        <p><br /></p>
        <p>
          <img
            src="https://hiraoka.com.pe/media/mageplaza/blog/post/q/u/qu_es_una_tarjeta_gr_fica_y_como_funciona.jpg"
          /><br />
        </p>
        <p class="text">
          Una tarjeta gráfica se compone, básicamente, de un controlador de
          video, de la memoria de pantalla o RAM video, y el generador de
          caracteres, y en la actualidad también poseen un acelerador de
          gráficos. El controlador de video va leyendo a intervalos la
          información almacenada en la RAM video y la transfiere al monitor en
          forma de señal de video; el número de veces por segundo que el
          contenido de la RAM video es leído y transmitido al monitor en forma
          de señal de video se conoce como frecuencia de refresco de la
          pantalla.
        </p>
        <p><br /></p>
        <h2 id="3.2">3.2 Aplicaciones</h2>
        <hr />
        <h1 id="3.2.1">3.2.1 Entrada/Salida</h1>
        <p class="text">
          En informática, un periférico de entrada/salida o E/S (en inglés:
          input/output o I/O) es aquel tipo de dispositivo periférico de un
          computador capaz de interactuar con los elementos externos a ese
          sistema de forma bidireccional, es decir, que permite tanto que sea
          ingresada información desde un sistema externo, como emitir
          información a partir de ese sistema. Los Dispositivos Periféricos de
          entrada son todos aquellos dispositivos que permiten introducir datos
          o información en una computadora para que esta los procese u ordene.
        </p>
        <p><br /></p>
        <p class="text">
          <b>Funciones: <br /> </b> Un periférico de E/S es el que se utiliza
          para ingresar (E) datos a la computadora, y luego de ser procesados
          por la unidad central de procesamiento (CPU), genera la salida (S) de
          información. Su función es leer o grabar, permanente o virtualmente,
          todo aquello que se haga con la computadora, para que pueda ser
          utilizado por los usuarios u otros sistemas.
        </p>
        <p><br /></p>
        <p class="text">
          <b>Tipos: <br /></b>Dispositivos o periféricos de comunicación entre
          computadoras, tales como módems y tarjetas de red, por lo general
          sirven para entrada y salida. También, los dispositivos de
          almacenamiento de datos, como los discos rígidos, la unidad de estado
          sólido, las memorias flash, las disqueteras, entre otros, se pueden
          considerar periféricos de entrada/salida.
        </p>
        <p><br /></p>
        <h1 id="3.2.2">3.2.2 Almacenamiento</h1>
        <p class="text">
          Conforme la tecnología avanza, más datos se van generando, por lo que
          es necesario contar con un almacenamiento eficiente para poder guardar
          toda esa información y acceder a ellos. El almacenamiento de datos ha
          cambiado mucho, desde los sistemas de disco, que muy probablemente se
          sigan utilizando, pero de una forma más digital: hoy se encuentran
          conectados a una red y son definidos por un software.
        </p>
        <p><br /></p>
        <p class="text">
          El almacenamiento de datos tiene un proceso a través del uso de la
          tecnología, ésta se aplica para organizar, distribuir y archivar
          información con los bytes y los bits que son parte de los sistemas de
          los que la gente depende día con día, llega a ser tan importante en
          todos los servicios: desde una simple aplicación, contenido
          multimedia, direcciones, contactos, hasta protocolos de red y todo lo
          que tiene que ver con el mundo digital.
        </p>
        <p><br /></p>
        <h4><i> Memoria contra almacenamiento </i></h4>
        <p class="text">
          Generalmente, los usuarios de computadoras tienden a confundir los
          términos “memoria” y “almacenamiento” pues los emplean de manera
          indistinta, utilizándolos para referirse a la RAM (o memoria
          principal) o al disco duro. Desde el punto de vista técnico, ambos
          términos son prácticamente iguales pues tanto la RAM como el disco
          duro se utilizan para almacenar información, claro está, de formas
          distintas y para propósitos diferentes.
        </p>
        <p><br /></p>
        <p class="text">
          Mientras la memoria se refiere a la ubicación de los datos a corto
          plazo, el almacenamiento es el componente de su computadora que le
          permite almacenar y acceder a datos a largo plazo. Usualmente, el
          almacenamiento se da en forma de una unidad de estado sólido o un
          disco duro. El almacenamiento le permite acceder y almacenar sus
          aplicaciones, sistema operativo y archivos por un tiempo indefinido.
        </p>
        <p><br /></p>
        <h4><i> Almacenamiento en sistemas informáticos </i></h4>
        <p class="text">
          Un dispositivo de almacenamiento es un hardware que se utiliza
          principalmente para almacenar datos. Cada computadora de escritorio,
          computadora portátil, tablet y smartphone tendrán algún tipo de
          dispositivo de almacenamiento en su interior y también puedes obtener
          unidades de almacenamiento externo independientes que se pueden
          utilizar en varios dispositivos.
        </p>
        <ul class="indt">
          <li>Unidades de discos duros (HDD).</li>
          <li>Discos de estado sólido (SSD).</li>
        </ul>
        <p><br /></p>
        <h1 id="3.2.3">3.2.3 Fuentes de Alimentación</h1>
        <p class="text">
          Una fuente de alimentación es un componente esencial de cualquier
          dispositivo electrónico ya que es ella quien se encarga de darle vida.
          En cualquier equipo, por pequeño que sea, siempre hay una fuente de
          alimentación, aunque no la veamos.
        </p>
        <p><br /></p>
        <p class="text">
          En los ordenadores de sobremesa, la fuente de alimentación se
          encuentra generalmente en la parte inferior de la torre (en cajas
          antiguas se encuentra en la superior), y muchas cajas de ordenador
          optan por incorporar un compartimento para separarla del resto y ya de
          paso ocultar todos los cables salientes de ella.
        </p>
        <p><br /></p>
        <p class="text">
          Una fuente de alimentación sirve para dar energía a un dispositivo
          electrónico. Siguiendo con el tema de los ordenadores de sobremesa, la
          fuente de alimentación da energía a la placa base, CPU, tarjetas
          gráficas, HDDs, SSDs, ventiladores, lectores de CDs. En resumen,
          alimenta a todo lo que necesite energía, para ello hace uso de
          diferentes tipos de cables.
        </p>
        <p><br /></p>
        <p class="text">
          Las fuentes de alimentación proporcionan energía a los SSD y HDD
          mediante conectores SATA de energía, y a los ventiladores mediante
          conectores molex de 3 o 4 pines o bien mediante la propia placa base
          (que es alimentada con el conector de 24 pines ATX). De esta manera,
          todos los componentes reciben energía de la fuente de alimentación.
          Además, las fuentes protegen a todos los componentes mediante una gran
          cantidad de sistemas dedicados a ello.
        </p>
        <p><br /></p>
        <p class="text">
          Existen fuentes de alimentación que no requieren de ventilación, por
          lo que su refrigeración es completamente pasiva. Estos modelos suelen
          ser fuentes de medio-bajo voltaje con una alta eficiencia, para que el
          calor generado sea menor y se pueda llevar a cabo su disipación sin
          usar ni un solo ventilador acoplado a la fuente, con los que existan
          en la caja serán más que suficiente.
        </p>
        <p><br /></p>
        <h2 id="3.3">3.3 Ambientes de Servicio</h2>
        <hr />
        <p class="text">
          El negocio de proveer servicios de datos es mucho más complejo que la
          forma en la que se dan los tradicionales servicios, los primeros
          requieren de nuevos conocimientos y modelos de negocio, que con
          frecuencia se termina involucrando o necesitando la colaboración de
          terceras empresas. Por lo que se hace necesario que los operadores
          tradicionales transformen su negocio para ofrecer los servicios de
          datos con los niveles de servicio que el mercado exige.
        </p>
        <p><br /></p>
        <h1 id="3.3.1">3.3.1 Negocios</h1>
        1
        <p class="text">
          Definitivamente, la tecnología en general ha sido la causa principal y
          la acción más directa para la transformación del trabajo de las
          organizaciones en la posguerra del siglo XX. Tanto los bienes de
          capital "duros" (computadores, teléfonos, videos, facsímiles,
          grabadoras, etc.), como los programas y sistemas de información y
          comunicación en general, han incrementado enormemente la productividad
          y eficiencia de las organizaciones. Tenemos como ejemplos los
          siguientes: bases de datos en redes de todo orden y topología,
          sistemas de reservaciones en aerolíneas, sistemas de contabilidad y
          nóminas, archivos clínicos en centros de salud, sistemas de
          conmutación electrónica y un sin número de otras aplicaciones a
          procesos administrativos.
        </p>
        <p><br /></p>
        <h1 id="3.3.2">3.3.2 Industria</h1>
        <p class="text">
          La industrialización de los servicios de tecnología de información va
          a redefinir el mercado en términos de como las organizaciones evalúan,
          compran y seleccionan los servicios y como los vendedores desarrollan
          y establecen precios de los servicios.
        </p>
        <p><br /></p>
        <p class="text">
          Para lograr esta estandarización, se requiere un enfoque hacia las
          soluciones genéricas y esto debe ser responsabilidad de los
          proveedores, que deben de desarrollar, operar y administrar el
          resultado de estos genéricos de TI.
        </p>
        <p><br /></p>
        <p class="text">
          Aunque los servicios de TI están en proceso de madurez, la madurez de
          la industria se ha incrementado en aspectos evidentes, como la forma
          en que los servicios son implementados y administrados.
        </p>
        <p><br /></p>
        <h1 id="3.3.3">3.3.3 Comercio Electrónico</h1>
        <p class="text">
          El desarrollo de estas tecnologías y de las telecomunicaciones ha
          hecho que los intercambios de datos crezcan a niveles extraordinarios,
          simplificándose cada vez más y creando nuevas formas de comercio, y en
          este marco se desarrolla el Comercio Electrónico.
        </p>
        <p><br /></p>
        <p class="text">
          Se considera “Comercio Electrónico” al conjunto de aquellas
          transacciones comerciales y financieras realizadas a través del
          procesamiento y la transmisión de información, incluyendo texto,
          sonido e imagen.
        </p>
        <p><br /></p>
        <!-- Unidad 4 -->
        <h3>UNIDAD 4</h3>
        <a href="#4.1"
          ><li>4.1 Aspectos Básicos de la Computación Paralela</li></a
        >
        <a href="#4.2"><li>4.2 Tipos de Computación Paralela</li></a>
        <ul>
          <a href="#4.2.1"><li class="indt">4.2.1 Clasificación</li></a>
          <a href="#4.2.2"
            ><li class="indt">
              4.2.2 Arquitectura de Computadoras Secuenciales
            </li></a
          >
          <a href="#4.2.3"
            ><li class="indt">
              4.2.3 Organización de Direcciones de Memoria
            </li></a
          >
        </ul>
        <a href="#4.3"><li>4.3 Sistemas de Memoria Compartida</li></a>
        <ul>
          <a href="#4.3.1"
            ><li class="indt">
              4.3.1 Redes de Interconexión Dinámicas ó Indirectas
            </li></a
          >
          <ul>
            <a href="#4.3.1.1"
              ><li class="indt2">4.3.1.1 Redes de Medio Compartido</li></a
            >
            <a href="#4.3.1.2"
              ><li class="indt2">4.3.1.2 Redes Conmutadas</li></a
            >
          </ul>
        </ul>
        <a href="#4.4"
          ><li>4.4 Sistemas de Memoria Distribuida: Multiprocesadores</li></a
        >
        <ul>
          <a href="#4.4.1"
            ><li class="indt">4.4.1 Redes de Interconexión Estáticas</li></a
          >
        </ul>
        <a href="#4.5"><li>4.5 Casos de Estudio</li></a>
        <div>
          <h2 id="4.1">4.1 Aspectos Básicos de la Computación Paralela</h2>
          <hr />
          <p class="text">
            Computador paralelo: Conjunto de elementos de procesos
            independientes que operan de una forma conjunta para resolver
            problemas de elevado coste computacional.
          </p>
          <p><br /></p>
          <p class="text">
            Los programas informáticos paralelos son más difíciles de escribir
            que los secuenciales, porque la concurrencia introduce nuevos tipos
            de errores de software, siendo las condiciones de carrera los más
            comunes. La comunicación y sincronización entre diferentes subtareas
            son algunos de los mayores obstáculos para obtener un buen
            rendimiento del programa paralelo. La máxima aceleración posible de
            un programa como resultado de la paralelización se conoce como la
            ley de Amdahl.
          </p>
          <p><br /></p>
          <h4><i> Ley de Amdahl y Ley de Gustafson</i></h4>
          <p class="text">Ámbito de aplicación:</p>
          <p><br /></p>
          <p class="text">Desde la conexión de procesadores.</p>
          <p><br /></p>
          <p class="text">Hasta la conexión de computadores.</p>
          <p><br /></p>
          <h4><i> Dependencias</i></h4>
          <p class="text">
            Entender la dependencia de datos es fundamental en la implementación
            de algoritmos paralelos. Ningún programa puede ejecutar más
            rápidamente que la cadena más larga de cálculos dependientes
            (conocida como la ruta crítica), ya que los cálculos que dependen de
            cálculos previos en la cadena deben ejecutarse en orden. Sin
            embargo, la mayoría de los algoritmos no consisten sólo de una larga
            cadena de cálculos dependientes; generalmente hay oportunidades para
            ejecutar cálculos independientes en paralelo.
          </p>
          <p><br /></p>
          <h4>
            <i>
              Condiciones de carrera, exclusión mutua, sincronización, y
              desaceleración paralela.</i
            >
          </h4>
          <p class="text">
            Las subtareas en un programa paralelo a menudo son llamadas hilos.
            Algunas arquitecturas de computación paralela utilizan versiones más
            pequeñas y ligeras de hilos conocidas como hebras, mientras que
            otros utilizan versiones más grandes conocidos como procesos. Sin
            embargo, «hilos» es generalmente aceptado como un término genérico
            para las subtareas. Los hilos a menudo tendrán que actualizar
            algunas variables que se comparten entre ellos. Las instrucciones
            entre los dos programas pueden entrelazarse en cualquier orden.
          </p>
          <p><br /></p>
          <p class="text"><b>Grado de paralelismo: </b></p>
          <ul class="indt">
            <li>Muy grueso: Programas.</li>
            <li>Grueso: Subprogramas, tareas.</li>
            <li>Fino: Instrucción.</li>
            <li>Muy fino: Fases de instrucción.</li>
          </ul>
          <p><br /></p>
          <h4><i>Modelos de consistencia.</i></h4>
          <p class="text">
            Los lenguajes de programación en paralelo y computadoras paralelas
            deben tener un modelo de consistencia de datos también conocido como
            un modelo de memoria. El modelo de consistencia define reglas para
            las operaciones en la memoria del ordenador y cómo se producen los
            resultados.
          </p>
          <p><br /></p>
          <p class="text">
            Uno de los primeros modelos de consistencia fue el modelo de
            consistencia secuencial de Leslie Lamport. La consistencia
            secuencial es la propiedad de un programa en la que su ejecución en
            paralelo produce los mismos resultados que un programa secuencial.
          </p>
          <p><br /></p>
          <h4><i>Single Instruction, Single Data (SISD)</i></h4>
          <p class="text">
            Hay un elemento de procesamiento, que tiene acceso a un único
            programa y a un almacenamiento de datos. En cada paso, el elemento
            de procesamiento carga una instrucción y la información
            correspondiente y ejecuta esta instrucción. El resultado es guardado
            de vuelta en el almacenamiento de datos. Luego SISD es el computador
            secuencial convencional, de acuerdo al modelo de von Neumann.
          </p>
          <p><br /></p>
          <h4><i>Multiple Instruction, Single Data (MISD)</i></h4>
          <p class="text">
            Hay múltiples elementos de procesamiento, en el que cada cual tiene
            memoria privada del programa, pero se tiene acceso común a una
            memoria global de información. En cada paso, cada elemento de
            procesamiento de obtiene la misma información de la memoria y carga
            una instrucción de la memoria privada del programa. Este modelo es
            muy restrictivo y no se ha usado en ningún computador de tipo
            comercial.
          </p>
          <p><br /></p>
          <h4><i>Single Instruction, Multiple Data (SIMD)</i></h4>
          <p class="text">
            Hay múltiples elementos de procesamiento, en el que cada cual tiene
            acceso privado a la memoria de información (compartida o
            distribuida). Sin embargo, hay una sola memoria de programa, desde
            la cual una unidad de procesamiento especial obtiene y despacha
            instrucciones. En cada paso, cada unidad de procesamiento obtiene la
            misma instrucción y carga desde su memoria privada un elemento de
            información y ejecuta esta instrucción en dicho elemento. Para
            aplicaciones con un grado significante de paralelismo de
            información, este acercamiento puede ser muy eficiente.
          </p>
          <p><br /></p>
          <h4><i>Multiple Instruction, Multiple Data (MIMD)</i></h4>
          <p class="text">
            Hay múltiples unidades de procesamiento, en la cual cada una tiene
            tanto instrucciones como información separada. Cada elemento ejecuta
            una instrucción distinta en un elemento de información distinto. Los
            elementos de proceso trabajan asíncronamente. Los clusters son
            ejemplo son ejemplos del modelo MIMD.
          </p>
          <p><br /></p>
          <h2 id="4.2">4.2 Tipos de Computación Paralela</h2>
          <hr />
          <h4><i>Paralelismo a nivel de bit</i></h4>
          <p class="text">
            Desde el advenimiento de la integración a gran escala (VLSI) como
            tecnología de fabricación de chips de computadora en la década de
            1970 hasta alrededor de 1986, la aceleración en la arquitectura de
            computadores se lograba en gran medida duplicando el tamaño de la
            palabra en la computadora, la cantidad de información que el
            procesador puede manejar por ciclo.
          </p>
          <p><br /></p>
          <p class="text">
            Históricamente, los microprocesadores de 4 bits fueron sustituidos
            por unos de 8 bits, luego de 16 bits y 32 bits, esta tendencia
            general llegó a su fin con la introducción de procesadores de 64
            bits, lo que ha sido un estándar en la computación de propósito
            general durante la última década.
          </p>
          <p><br /></p>
          <h4><i>Paralelismo a nivel de instrucción</i></h4>
          <p class="text">
            Los procesadores modernos tienen ''pipeline'' de instrucciones de
            varias etapas. Cada etapa en el pipeline corresponde a una acción
            diferente que el procesador realiza en la instrucción
            correspondiente a la etapa; un procesador con un pipeline de N
            etapas puede tener hasta n instrucciones diferentes en diferentes
            etapas de finalización.
          </p>
          <p><br /></p>
          <h4><i>Paralelismo de datos</i></h4>
          <p class="text">
            El paralelismo de datos es el paralelismo inherente en programas con
            ciclos, que se centra en la distribución de los datos entre los
            diferentes nodos computacionales que deben tratarse en paralelo.
            Muchas de las aplicaciones científicas y de ingeniería muestran
            paralelismo de datos.
          </p>
          <p><br /></p>
          <p class="text">
            Una dependencia de terminación de ciclo es la dependencia de una
            iteración de un ciclo en la salida de una o más iteraciones
            anteriores. Las dependencias de terminación de ciclo evitan la
            paralelización de ciclos.
          </p>
          <p><br /></p>
          <p>
            <img
              src="http://ferestrepoca.github.io/paradigmas-de-programacion/paralela/paralela_teoria/images/cvsa.png"
            /><br />
          </p>
          <h4><i>Paralelismo de tareas</i></h4>
          <p class="text">
            Es un paradigma de la programación concurrente que consiste en
            asignar distintas tareas a cada uno de los procesadores de un
            sistema de cómputo. En consecuencia, cada procesador efectuará su
            propia secuencia de operaciones. En su modo más general, el
            paralelismo de tareas se representa mediante un grafo de tareas, el
            cual es subdividido en subgrafos que son luego asignados a
            diferentes procesadores.
          </p>
          <p><br /></p>
          <h1 id="4.2.1">4.2.1 Clasificación</h1>
          <p class="text">
            Las computadoras paralelas se pueden clasificar de acuerdo con el
            nivel en el que el hardware soporta paralelismo. Esta clasificación
            es análoga a la distancia entre los nodos básicos de cómputo.
          </p>
          <p><br /></p>
          <p class="text">
            <b>Computación multinúcleo: </b>un procesador multinúcleo es un
            procesador que incluye múltiples unidades de ejecución (núcleos) en
            el mismo chip.
          </p>
          <p><br /></p>
          <p class="text">
            <b>Multiprocesamiento simétrico: </b>un multiprocesador simétrico
            (SMP) es un sistema computacional con múltiples procesadores
            idénticos que comparten memoria y se conectan a través de un bus.
          </p>
          <p><br /></p>
          <p class="text">
            <b>Computación en clúster: </b>un clúster es un grupo de ordenadores
            débilmente acoplados que trabajan en estrecha colaboración, de modo
            que en algunos aspectos pueden considerarse como un solo equipo.
          </p>
          <p><br /></p>
          <p class="text">
            <b>Procesamiento paralelo masivo: </b>tienden a ser más grandes que
            los clústeres, con «mucho más» de 100 procesadores.
          </p>
          <p><br /></p>
          <p class="text">
            <b>Computación distribuida: </b>la computación distribuida es la
            forma más distribuida de la computación paralela. Se hace uso de
            ordenadores que se comunican a través de la Internet para trabajar
            en un problema dado.
          </p>
          <p><br /></p>
          <p class="text">
            <b>Circuitos integrados de aplicación específica: </b>debido a que
            un ASIC (por definición) es específico para una aplicación dada,
            puede ser completamente optimizado para esa aplicación.
          </p>
          <p><br /></p>
          <p class="text">
            <b>Procesadores vectoriales: </b>pueden ejecutar la misma
            instrucción en grandes conjuntos de datos.
          </p>
          <p><br /></p>
          <h1 id="4.2.2">4.2.2 Arquitectura de Computadoras Secuenciales</h1>
          <p class="text">
            A diferencia de los sistemas combinacionales, en los sistemas
            secuenciales, los valores de las salidas, en un momento dado, no
            dependen exclusivamente de los valores de las entradas en dicho
            momento, sino también dependen del estado anterior o estado interno.
          </p>
          <p><br /></p>
          <p class="text">
            El sistema secuencial requiere de la utilización de un dispositivo
            de memoria que pueda almacenar la historia pasada de sus entradas
            (denominadas variables de estado) y le permita mantener su estado
            durante algún tiempo, estos dispositivos de memoria pueden ser
            sencillos como un simple retardador o celdas de memoria de tipo
            DRAM, SRAM o multivibradores biestables también conocido como
            Flip-Flop.
          </p>
          <p><br /></p>
          <h4><i>Tipos de sistemas secuenciales</i></h4>
          <p class="text">
            En este tipo de circuitos entra un factor que no se había
            considerado en los circuitos combinacionales, dicho factor es el
            tiempo, según como manejan el tiempo se pueden clasificar en:
            circuitos secuenciales síncronos y circuitos secuenciales
            asíncronos.
          </p>
          <p><br /></p>
          <h4><i>Circuitos secuenciales asíncronos</i></h4>
          <p class="text">
            En circuitos secuenciales asíncronos los cambios de estados ocurren
            al ritmo natural asociado a las compuertas lógicas utilizadas en su
            implementación, lo que produce retardos en cascadas entre los
            biestables del circuito, es decir no utilizan elementos especiales
            de memoria, lo que puede ocasionar algunos problemas de
            funcionamiento, ya que estos retardos naturales no están bajo el
            control del diseñador y además no son idénticos en cada compuerta
            lógica.
          </p>
          <p><br /></p>
          <h4><i>Circuitos secuenciales síncronos</i></h4>
          <p class="text">
            Los circuitos secuenciales síncronos solo permiten un cambio de
            estado en los instantes marcados o autorizados por una señal de
            sincronismo de tipo oscilatorio denominada reloj (cristal o circuito
            capaz de producir una serie de pulsos regulares en el tiempo), lo
            que soluciona los problemas que tienen los circuitos asíncronos
            originados por cambios de estado no uniformes dentro del sistema o
            circuito.
          </p>
          <p><br /></p>
          <h1 id="4.2.3">4.2.3 Organización de Direcciones de Memoria</h1>
          <p class="text">
            La memoria de acceso secuencial son memorias en la cuales para
            acceder a un registro en particular se tienen que leer registro por
            registro desde el inicio hasta alcanzar el registro particular que
            contiene el dato que se requiere. Estas memorias se clasifican en:
          </p>
          <p><br /></p>
          <p class="text">Registros de desplazamiento</p>
          <p><br /></p>
          <p class="text">Dispositivos por acoplamiento por carga</p>
          <p><br /></p>
          <p class="text">Memorias de burbuja</p>
          <p><br /></p>
          <p>
            <img
              src="https://img-aws.ehowcdn.com/750x500/photos.demandstudios.com/197/59/fotolia_256152_XS.jpg"
            /><br />
          </p>
          <p class="text">
            Los accesos a la memoria local suelen ser más rápidos que los
            accesos a memoria no local. Las arquitecturas de ordenador en las
            que cada elemento de la memoria principal se puede acceder con igual
            latencia y ancho de banda son conocidas como arquitecturas de acceso
            uniforme a memoria (UMA).
          </p>
          <p><br /></p>
          <p class="text">
            Un sistema que no tiene esta propiedad se conoce como arquitectura
            de acceso a memoria no uniforme (NUMA). Los sistemas de memoria
            distribuidos tienen acceso no uniforme a la memoria.
          </p>
          <p><br /></p>
          <h2 id="4.3">4.3 Sistemas de Memoria Compartida</h2>
          <hr />
          <p class="text"></p>
          <ul class="indt">
            <li>Todos los procesadores acceden a una memoria común.</li>
            <li>
              La comunicación entre procesadores se hace a través de la memoria.
            </li>
            <li>
              Se necesitan primitivas de sincronismo para asegurar el
              intercambio de datos.
            </li>
          </ul>
          <p><br /></p>
          <h4>
            <i>Estructura de los multiprocesadores de memoria compartida</i>
          </h4>
          <p class="text">
            La mayoría de los multiprocesadores comerciales son del tipo UMA
            (Uniform Memory Access): todos los procesadores tienen igual tiempo
            de acceso a la memoria compartida. En la arquitectura UMA los
            procesadores se conectan a la memoria a través de un bus, una red
            multietapa o un conmutador de barras cruzadas (crossbar crossbar) y
            disponen de su propia memoria caché. Los procesadores tipo NUMA (Non
            Uniform Memory Access) presentan tiempos de acceso a la memoria
            compartida que dependen de la ubicación del elemento de proceso y la
            memoria.
          </p>
          <p><br /></p>
          <h1 id="4.3.1">
            4.3.1 Redes de Interconexión Dinámicas ó Indirectas
          </h1>
          <p class="text">
            Medio compartido. <br />
            Conexión por bus compartido.
          </p>
          <p><br /></p>
          <p class="text">
            Es la organización más común en los computadores personales y
            servidores.
          </p>
          <p><br /></p>
          <p class="text">
            El bus consta de líneas de dirección, datos y control para
            implementar:
          </p>
          <ul class="indt">
            <li>El protocolo de transferencias de datos con la memoria.</li>
            <li>
              El arbitraje del acceso al bus cuando más de un procesador compite
              por utilizarlo.
            </li>
          </ul>
          <p><br /></p>
          <p class="text">Los procesadores utilizan cachés locales para:</p>
          <ul class="indt">
            <li>
              Reducir el tiempo medio de acceso a memoria, como en un
              monoprocesador.
            </li>
            <li>Disminuir la utilización del bus compartido.</li>
          </ul>
          <p><br /></p>
          <h4><i>Protocolos de transferencia de ciclo partido</i></h4>
          <p class="text">
            La operación de lectura se divide en dos transacciones no continuas
            de acceso al bus. La primera es de petición de lectura que realiza
            el máster (procesador) sobre el slave (memoria). Cuando el slave
            dispone del dato leído, inicia un ciclo de bus actuando como máster
            para enviar el dato al antiguo máster, que ahora actúa como slave.
          </p>
          <p><br /></p>
          <h4><i>Protocolo de arbitraje distribuido</i></h4>
          <p class="text">
            La responsabilidad del arbitraje se distribuye por los diferentes
            procesadores conectados al bus.
          </p>
          <p><br /></p>
          <h1 id="4.3.1.2">4.3.1.2 Redes Conmutadas</h1>
          <p class="text">Conexión por conmutadores crossbar.</p>
          <p><br /></p>
          <p class="text">
            Cada procesador (Pi) y cada módulo de memoria (Mi) tienen su propio
            bus. Existe un conmutador (S) en los puntos de intersección que
            permite conectar un bus de memoria con un bus de procesador. Para
            evitar conflictos cuando más de un procesador pretende acceder al
            mismo módulo de memoria se establece un orden de prioridad.
          </p>
          <p><br /></p>
          <h4><i>Conexión por red multietapa.</i></h4>
          <p class="text"></p>
          <ul class="indt">
            <li>
              Representan una alternativa intermedia de conexión entre el bus y
              el crossbar.
            </li>
            <li>
              Es de menor complejidad que el crossbar pero mayor que el bus
              simple.
            </li>
            <li>
              La conectividad es mayor que la del bus simple pero menor que la
              del crossbar.
            </li>
            <li>
              Se compone de varias etapas alternativas de conmutadores simples y
              redes de interconexión.
            </li>
          </ul>
          <p><br /></p>
          <h2 id="4.4">
            4.4 Sistemas de Memoria Distribuida: Multiprocesadores
          </h2>
          <hr />
          <p class="text">
            Cada procesador tiene su propia memoria y la comunicación se realiza
            por intercambio explícito de mensajes a través de una red.
          </p>
          <p><br /></p>
          <h4><i>Ventajas</i></h4>
          <p class="text"></p>
          <ul class="indt">
            <li>
              El número de nodos puede ir desde algunas decenas hasta varios
              miles (o más).
            </li>
            <li>
              La arquitectura de paso de mensajes tiene ventajas sobre la de
              memoria compartida cuando el número de procesadores es grande.
            </li>
            <li>
              El número de canales físicos entre nodos suele oscilar entre
              cuatro y ocho.
            </li>
            <li>
              Esta arquitectura es directamente escalable y presenta un bajo
              coste para sistemas grandes.
            </li>
          </ul>
          <p><br /></p>
          <h4><i>Desventajas</i></h4>
          <p class="text"></p>
          <ul class="indt">
            <li>
              Se necesitan técnicas de sincronización para acceder a las
              variables compartidas.
            </li>
            <li>
              La contención en la memoria puede reducir significativamente la
              velocidad.
            </li>
            <li>
              No son fácilmente escalables a un gran número de procesadores.
            </li>
          </ul>
          <p><br /></p>
          <h1 id="4.4.1">4.4.1 Redes de Interconexión Estáticas</h1>
          <p class="text">
            Los multicomputadores utilizan redes estáticas con enlaces directos
            entre nodos. Cuando un nodo recibe un mensaje lo procesa si viene
            dirigido a dicho nodo. Si el mensaje no va dirigido al nodo receptor
            lo reenvía a otro por alguno de sus enlaces de salida siguiendo un
            protocolo de encaminamiento.
          </p>
          <p><br /></p>
          <h4><i>Propiedades más significativas</i></h4>
          <p class="text"></p>
          <ul class="indt">
            <li>
              Topología de la red: determina el patrón de interconexión entre
              nodos.
            </li>
            <li>
              Diámetro de la red: distancia máxima de los caminos más cortos
              entre dos nodos de la red.
            </li>
            <li>
              Latencia: retardo de tiempo en el peor caso para un mensaje
              transferido a través de la red.
            </li>
            <li>
              Ancho de banda: Transferencia máxima de datos en Mbytes/segundo.
            </li>
            <li>Escalabilidad: posibilidad de expansión modular de la red.</li>
            <li>
              Grado de un nodo: número de enlaces o canales que inciden en el
              nodo.
            </li>
            <li>
              Algoritmo de encaminamiento: determina el camino que debe seguir
              un mensaje desde el nodo emisor al nodo receptor.
            </li>
          </ul>
          <p><br /></p>
          <h2 id="4.5">4.5 Casos de Estudio</h2>
          <hr />
          <p class="text">
            Por numerosos motivos, el procesamiento distribuido se ha convertido
            en un área de gran importancia e interés dentro de la ciencia de la
            computación, produciendo profundas transformaciones en las líneas de
            investigación y desarrollo.
          </p>
          <p><br /></p>
          <p class="text">
            Interesa realizar investigación en la especificación,
            transformación, optimización y evaluación de algoritmos distribuidos
            y paralelos. Esto incluye el diseño y desarrollo de sistemas
            paralelos, la transformación de algoritmos secuenciales en
            paralelos, y las métricas de evaluación de performance sobre
            distintas plataformas de soporte (hardware y software). Más allá de
            las mejoras constantes en las arquitecturas físicas de soporte, uno
            de los mayores desafíos se centra en cómo aprovechar al máximo la
            potencia de las mismas.
          </p>
          <p><br /></p>
          <h4><i>Líneas de investigación y desarrollo</i></h4>
          <p class="text"></p>
          <ul class="indt">
            <li>
              Paralelización de algoritmos secuenciales. Diseño y optimización
              de algoritmos.
            </li>
            <li>Arquitecturas multicore y multithreading en multicore.</li>
            <li>
              Modelos de representación y predicción de performance de
              algoritmos paralelos.
            </li>
            <li>
              Mapping y scheduling de aplicaciones paralelas sobre distintas
              arquitecturas multiprocesador.
            </li>
            <li>
              Métricas del paralelismo. Speedup, eficiencia, rendimiento,
              granularidad, superlinealidad.
            </li>
            <li>
              Balance de carga estático y dinámico. Técnicas de balanceo de
              carga.
            </li>
            <li>
              Análisis de los problemas de migración y asignación óptima de
              procesos y datos a procesadores.
            </li>
            <li>Patrones de diseño de algoritmos paralelos.</li>
            <li>
              Escalabilidad de algoritmos paralelos en arquitecturas
              multiprocesador distribuidas.
            </li>
            <li>
              Implementación de soluciones sobre diferentes modelos de
              arquitectura homogéneas y heterogéneas.
            </li>
            <li>
              Laboratorios remotos para el acceso transparente a recursos de
              cómputo paralelo.
            </li>
          </ul>
          <p><br /></p>
          <h4><i>Algunas Implementaciones con procesamiento paralelo.</i></h4>
          <p class="text"><b>NVIDIA</b><br />Capa física (physical layer):</p>
          <ul class="indt">
            <li>GPU PhysX</li>
            <li>CPU PhysX</li>
          </ul>
          Capa de gráficos (graphics layer):
          <ul class="indt">
            <li>GPU DirectX Windows</li>
          </ul>
          <p><br /></p>
          <p class="text"><b>Intel</b><br />Capa física (physical layer):</p>
          <ul class="indt">
            <li>No GPU PhysX</li>
            <li>CPU Havok</li>
          </ul>
          Capa de gráficos (graphics layer):
          <ul class="indt">
            <li>GPU DirectX Windows</li>
          </ul>
          <p><br /></p>
          <p class="text"><b>AMD</b><br />Capa física (physical layer):</p>
          <ul class="indt">
            <li>No GPU PhysX</li>
            <li>CPU Havok</li>
          </ul>
          Capa de gráficos (graphics layer):
          <ul class="indt">
            <li>GPU DirectX Windows</li>
          </ul>
          <p><br /></p>
        </div>
        <footer
          class="bg-black border-t border-indigo-800 text-white w-full h-full px-20 py-10"
        >
          <div class="flex flex-row justify-center py-5">
            <a href="#"
              ><img
                src="../../_astro/facebook.d0460cb1_gLov.webp"
                class="bg-white w-11 mx-3 rounded-full"
                alt="Icon"
                width="48"
                height="48"
                loading="lazy"
                decoding="async"
            /></a>
            <a href="https://github.com/fernandovmedina"
              ><img
                src="../../_astro/github.399343f1_1pEorC.webp"
                class="bg-white w-11 mx-3 rounded-full"
                alt="Icon"
                width="50"
                height="50"
                loading="lazy"
                decoding="async"
            /></a>
            <a href="#"
              ><img
                src="../../_astro/instagram.02d53076_ZRceRR.webp"
                class="bg-white w-11 mx-3 rounded-full"
                alt="Icon"
                width="48"
                height="48"
                loading="lazy"
                decoding="async"
            /></a>
            <a href="#"
              ><img
                src="../../_astro/gmail.e2480db4_26vAjj.webp"
                class="bg-white w-11 mx-3 rounded-full"
                alt="Icon"
                width="96"
                height="96"
                loading="lazy"
                decoding="async"
            /></a>
          </div>
          <div
            class="flex flex-col text-center text-sm md:text-lg w-full text-white h-full"
          >
            <h1>Creada por @Fernando Alejandro Vazquez Medina</h1>
          </div>
        </footer>
      </div>
    </section>
  </body>
</html>
